<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello world</title>
    <url>/2021/06/16/hello-world/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>6.824 lab1 MapReduce</title>
    <url>/2021/07/18/6-824-lab1-MapReduce/</url>
    <content><![CDATA[<h1 id="论文实现"><a href="#论文实现" class="headerlink" title="论文实现"></a>论文实现</h1><p><img src="https://i.loli.net/2021/07/18/qE9BlI63GyvCn45.png" alt="image.png"></p>
<p>看这个流程就基本明白了，</p>
<ol>
<li>每一个worker（master worker 特殊一点）都有相应的program，</li>
<li>master分配相应的task（map or reduce）给各个worker</li>
<li>input被分成多个splits到map worker上input splits被map function处理（给每一个input中的data加上key，形成intermediate key&#x2F;value pairs）</li>
<li>intermediate key&#x2F;value pairs（in memory）被periodically写入本地磁盘，这个pair的位置就会返回给master，然后master负责转发这些位置给reduce worker</li>
<li>reduce worker得知后，就使用<code>rpc</code>读取map worker磁盘中的数据（intermediate key&#x2F;value pairs），然后根据key对pairs进行排序，然后将key相同的聚合。（也就是现在的数据，每一个key有着一系列的values）</li>
<li>迭代数据，将key相同的输入reduce function，输出被添加到输出文件中</li>
<li>所有计算完成，master返回给user code</li>
</ol>
<p>注意：之后的output files一般并不需要合并，通常作为下一个<code>MapReduce</code>程序的输出，或者其他具有读取分布式文件能力的程序。</p>
<p>简洁版：<strong>map负责将input分类，reduce负责处理每一类数据</strong>，OVER。</p>
<h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="0-github地址"><a href="#0-github地址" class="headerlink" title="0. github地址"></a>0. <a href="https://github.com/TYTaO/have-a-try-824">github地址</a></h2><h2 id="1-实现master与wroker的rpc通信"><a href="#1-实现master与wroker的rpc通信" class="headerlink" title="1. 实现master与wroker的rpc通信"></a>1. 实现master与wroker的rpc通信</h2><p>通过单独建一个包，用rpc.go规定两者之间的数据结构（待更优雅的解决方式）</p>
<p>worker需要使用rpc call两次</p>
<ul>
<li>一次拿任务</li>
<li>一次告诉master任务执行完毕</li>
</ul>
<h2 id="2-实现超时问题（解决worker挂掉的情况）"><a href="#2-实现超时问题（解决worker挂掉的情况）" class="headerlink" title="2. 实现超时问题（解决worker挂掉的情况）"></a>2. 实现超时问题（解决worker挂掉的情况）</h2><h4 id="遇见一个range问题"><a href="#遇见一个range问题" class="headerlink" title="遇见一个range问题"></a>遇见一个range问题</h4><p>range 数组时，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分发任务</span></span><br><span class="line"><span class="keyword">for</span> i, task := <span class="keyword">range</span> m.tasks &#123;  <span class="comment">// 这里m.tasks[i]是一个副本，而不是指向m.tasks[i]的指针，也就是对task的改动</span></span><br><span class="line"><span class="comment">// 不能影响m.tasks[i]</span></span><br><span class="line">    <span class="keyword">if</span> m.tasks[i].state == GENERATED &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Distribute a task %d\n&quot;</span>, m.tasks[i].id)</span><br><span class="line">        reply.T = Task&#123;Id: m.tasks[i].id&#125;</span><br><span class="line">        m.tasks[i].state = DISTRIBUTED</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全局变量问题"><a href="#全局变量问题" class="headerlink" title="全局变量问题"></a>全局变量问题</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m *Master</span><br><span class="line"><span class="keyword">var</span> chans []<span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 用来传输任务已完成</span></span><br><span class="line"><span class="comment">// 通过rpc 给worker发任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m = MakeMaster(<span class="number">10</span>) <span class="comment">// m := MakeMaster(10) 的话，m就不是全局变量了，</span></span><br><span class="line">	chans = <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> m.Done() == <span class="literal">false</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-实现不同任务的分发与协作"><a href="#3-实现不同任务的分发与协作" class="headerlink" title="3. 实现不同任务的分发与协作"></a>3. 实现不同任务的分发与协作</h2><blockquote>
<p>两个task，A，B。B依赖于A</p>
</blockquote>
<h4 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h4><h4 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h4><h4 id="实现具体的map-reduce"><a href="#实现具体的map-reduce" class="headerlink" title="实现具体的map reduce"></a>实现具体的map reduce</h4><h2 id="4-实现固定Reduce的输出文件数量"><a href="#4-实现固定Reduce的输出文件数量" class="headerlink" title="4. 实现固定Reduce的输出文件数量"></a>4. 实现固定Reduce的输出文件数量</h2><h4 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h4><blockquote>
<p>ensure that nobody observes partially written files in the presence of crashes， use <code>ioutil.TempFile</code> to create a temporary file and <code>os.Rename</code> to atomically rename it.</p>
</blockquote>
<h4 id="需要实现不同reduce-task对相对task-id结果的一个融合"><a href="#需要实现不同reduce-task对相对task-id结果的一个融合" class="headerlink" title="需要实现不同reduce task对相对task id结果的一个融合"></a>需要实现不同reduce task对相对task id结果的一个融合</h4><h4 id="ihash"><a href="#ihash" class="headerlink" title="ihash"></a>ihash</h4><p>其是对key（：word）进行hash，所以word相同的会到同一个reduce中。得大改代码了。。</p>
<p>map task输出 多个<code>mr-X-Y</code>, where X is the Map task number, and Y is the reduce task number.</p>
<h4 id="Workers-will-sometimes-need-to-wait-e-g-reduces-can’t-start-until-the-last-map-has-finished"><a href="#Workers-will-sometimes-need-to-wait-e-g-reduces-can’t-start-until-the-last-map-has-finished" class="headerlink" title="Workers will sometimes need to wait, e.g. reduces can’t start until the last map has finished."></a>Workers will sometimes need to wait, e.g. reduces can’t start until the last map has finished.</h4><p>说明reduce任务不能先执行，之前一直纠结于让reduce和map一起执行，然后reduce中间结果的问题。。。</p>
<blockquote>
<p>一个map task finished后，保存其生成的中间文件（存入m.reduceTaskFiles）。等到所有map结束后再生成reduce task</p>
</blockquote>
<h4 id="遇到一个占有锁不放（条件不满足），而另一个是来解决问题的，也进不去锁"><a href="#遇到一个占有锁不放（条件不满足），而另一个是来解决问题的，也进不去锁" class="headerlink" title="遇到一个占有锁不放（条件不满足），而另一个是来解决问题的，也进不去锁"></a>遇到一个占有锁不放（条件不满足），而另一个是来解决问题的，也进不去锁</h4><h4 id="得在返回之前释放锁鸭！！！！"><a href="#得在返回之前释放锁鸭！！！！" class="headerlink" title="得在返回之前释放锁鸭！！！！"></a>得在返回之前释放锁鸭！！！！</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m.mtx.Unlock()</span><br><span class="line"><span class="keyword">if</span> hasDistribute &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// m.mtx.Unlock()   // ×</span></span><br></pre></td></tr></table></figure>

<h2 id="5-map并行测试不通过"><a href="#5-map并行测试不通过" class="headerlink" title="5. map并行测试不通过"></a>5. map并行测试不通过</h2><h4 id="一直timeout"><a href="#一直timeout" class="headerlink" title="一直timeout"></a>一直timeout</h4><p>mtiming的map相当废时间，每执行一次要1s，10个nReduce就是10s            </p>
<blockquote>
<p>先对整体执行一次mapf，之后对mapf的结果进行分段，而不是先分段。</p>
</blockquote>
<h4 id="执行20次mapf，让test误以为是20个并行"><a href="#执行20次mapf，让test误以为是20个并行" class="headerlink" title="执行20次mapf，让test误以为是20个并行"></a>执行20次mapf，让test误以为是20个并行</h4><blockquote>
<p>先对整体执行一次mapf，之后对mapf的结果进行分段，而不是先分段。</p>
</blockquote>
<h2 id="6-crash-test不通过"><a href="#6-crash-test不通过" class="headerlink" title="6. crash test不通过"></a>6. crash test不通过</h2><p>我每次map task会调用10次mapf，而test设置的每次mapf都会有几率crash，所以得接着进行map，不能每次从头开始？</p>
<p>map时间太长了，应该是我写的有问题。。</p>
<h4 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h4><ul>
<li>一次map task 10 次 crash机会</li>
<li>map时间过长，容易超时</li>
</ul>
<blockquote>
<p>先对整体执行一次mapf，之后对mapf的结果进行分段，而不是先分段。</p>
</blockquote>
<h4 id="所有的worker的request都在wait-map-task-finished"><a href="#所有的worker的request都在wait-map-task-finished" class="headerlink" title="所有的worker的request都在wait map task finished"></a>所有的worker的request都在wait map task finished</h4><p>之前把map task都分配后，再有request就进入wait map task finished阶段，但有map task crash了！！</p>
<p>就导致无限等待了</p>
]]></content>
      <categories>
        <category>Online Course</category>
      </categories>
      <tags>
        <tag>6.824</tag>
        <tag>Distributed Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/2021/06/28/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h4 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h4><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">leetcode 153</a></p>
<h4 id="Key-of-Solution"><a href="#Key-of-Solution" class="headerlink" title="Key of Solution"></a>Key of Solution</h4><p>在于选择mi与le还是ri比较。通过找规律，可以发现两种情况下nums[mi]与nums[le], nums[ri]的关系（也就是作为缩小范围的依据）都会改变。</p>
<p>然后mi的计算方式可能会有mi&#x3D;&#x3D;le的情况，其成为特例破坏我们预设的规则，所以选择nums[mi]与nums[ri]的比较，完美解决此题。</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">le</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ri</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (le &lt; ri) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> (le + ri) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mi] &gt; nums[ri]) &#123;</span><br><span class="line">                le = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ri = mi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[le];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Aalgorithm</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Useful Blog</title>
    <url>/2023/03/19/Useful-Blog/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>地址</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.yezhem.com/index.php/archives/58/">https://www.yezhem.com/index.php/archives/58/</a></td>
<td>给hyper-v虚拟机固定静态IP</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>Git Learning</title>
    <url>/2023/03/20/Git-Learning/</url>
    <content><![CDATA[<h1 id="重学git"><a href="#重学git" class="headerlink" title="重学git"></a>重学git</h1><p>ref: <a href="https://www.atlassian.com/zh/git/tutorials">https://www.atlassian.com/zh/git/tutorials</a>, <a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p>
<h2 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h2><ul>
<li>Git 的协作模式基于代码库与代码库之间的互动，也就是不是将工作副本检入 SVN 的中央代码库，而是<strong>将提交从一个代码库推送或拉取到另一个代码库。</strong></li>
</ul>
<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><img src="/images/image-20230320215241571.png" alt="image-20230320215241571" style="zoom: 50%;" />

<p>git clone主要用于指向现有的repo，并在另一个位置的新目录中对该repo进行<strong>克隆或复制</strong>。原始存储库可以位于本地文件系统上，也可以位于远程机器可访问的支持协议上。git clone命令复制现有的git存储库。它有自己的历史记录，管理自己的文件，并且是一个与原始存储库完全隔离的环境。</p>
<p>为了方便起见，克隆会自动创建一个名为“origin”的远程连接，指向原始存储库。这使得与中央存储库进行交互变得非常容易。这种自动连接是通过在<code>refs/remotes/origin</code>下创建到远程分支头的Git引用，并通过初始化<code>remote.origin.url</code>和<code>remote.origing.fetch</code>配置变量来建立的。</p>
<h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>在 Git 或其他版本控制系统中工作时，“保存”的概念比在文字处理器或其他传统文件编辑应用中保存的流程更为细致。传统的软件表达方式“保存”与 Git 术语“提交”同义。Git 中的提交相当于“保存”。应将传统保存视为一种用于覆盖现有文件或写入新文件的文件系统操作。或者，<strong>Git 提交是一种作用于文件和目录集合的操作</strong>。</p>
<p>在 Git 和 SVN 中保存变更也是不同的流程。SVN 提交或“签入”是指远程推送到集中式服务器的操作。这意味着 SVN 提交需要访问互联网才能完全“保存”项目变更。Git 提交可以在本地捕获和构建，然后根据需要使用 <code>git push-u origin</code> 主命令推送到远程服务器。这两种方法之间的区别是架构设计之间的根本区别。<strong>Git 是分布式应用模型</strong>，而 SVN 是集中式模型。分布式应用通常更强大，因为它们不像集中式服务器那样存在单点故障。</p>
<p>Git 还有一个名为 “the stash” 的额外保存机制。<strong>stash 是一个临时存储区，用于存放尚未准备提交的变更</strong>。stash 在工作目录上运行，工作目录是<a href="https://www.atlassian.com/zh/git/tutorials/undoing-changes/git-reset">三棵树</a>中的第一个，有大量的使用选项。要了解更多信息，请访问 <code>git stash</code> 页面。</p>
<p>可以将 Git 存储库配置为<strong>忽略特定的文件或目录。这将防止 Git 保存对任何忽略内容的变更</strong>。Git 有多种管理忽略列表的配置方法。Git 忽略配置在 <code>git ignore</code> 页面中有更详细的介绍。</p>
<h4 id="git-add-1"><a href="#git-add-1" class="headerlink" title="git add"></a>git add</h4><p><code>git add</code> 命令将工作目录中的变更添加到暂存区域。它告诉 Git 您想在下一次提交中包含对特定文件的更新。但是，<code>git add</code> 并没有真正对存储库产生任何重大影响，只有在您运行 <code>git commit</code> 后才会真正记录提交。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><code>git add</code> 和 <code>git commit</code> 命令构成了基本的 Git 工作流程。这是每个 Git 用户需要理解的两个命令，无论他们的团队采用何种协作模式。它们是将项目版本记录到存储库历史记录中的方法。</p>
<p><strong>开发项目围绕基本的编辑&#x2F;暂存&#x2F;提交模式进行</strong>：首先，在工作目录中编辑文件。当您准备好保存项目当前状态的副本时，您可以使用 <code>git add</code> 暂存变更。对暂存的快照感到满意后，您可以使用 <code>git commit</code> 将其提交到项目历史记录中。<code>git reset</code> 命令用于撤销提交或暂存的快照。除了 <code>git add</code> 和 <code>git commit</code> 外，第三个命令 <code>git push</code> 对于完整的协作 Git 工作流程至关重要。<code>git push</code> 用于将提交的变更发送到远程存储库进行协作。这使其他团队成员能够访问一组已保存的变更。每次修改文件时都需要调用 <code>git add</code>，这听起来可能多余，但是这种工作流程使保持项目井然有序变得容易得多。</p>
<h4 id="暂存区域"><a href="#暂存区域" class="headerlink" title="暂存区域"></a>暂存区域</h4><p><code>git add</code> 命令的主要功能是将工作目录中待处理的变更提升到 <code>git staging</code> 区域。暂存区域是 Git 比较独特的功能之一，暂存区域被认为是 <a href="https://www.atlassian.com/zh/git/tutorials/undoing-changes/git-reset">Git 的“三棵树”</a>之一，还有工作目录和提交历史记录。</p>
<p>暂存不必提交自上次提交以来所做的所有变更，而是在将相关变更实际提交到项目历史记录之前，<strong>将相关变更分组为高度集中的快照</strong>。这<strong>意味着您可以对不相关的文件进行各种编辑，然后返回并将它们拆分为逻辑提交</strong>，<strong>方法是将相关变更添加到暂存并逐段提交</strong>。与任何版本控制系统一样，<strong>创建原子提交很重要，这样可以轻松跟踪错误并还原变更</strong>，同时最大限度地减少对项目其余部分的影响。</p>
<blockquote>
<p>add 和 commit分开的原因：</p>
<ul>
<li>add方便对更改进行拆分，可以对不相关的文件进行各种编辑，然后返回并将它们拆分为逻辑提交。方法是将相关变更添加到暂存并逐段提交</li>
</ul>
</blockquote>
<p>总结：</p>
<p>综上所述，<code>git add</code> 是一系列操作中的第一个命令，它指示 Git 将当前项目状态的快照“保存”到提交历史记录中。单独使用时，<code>git add</code> 会将待处理的变更从工作目录提升到暂存区域。<code>git status</code> 命令用于检查存储库的当前状态，也可用于确认 <code>git add</code> 升级。<code>git reset</code> 命令用于撤销 <code>git add</code>。然后，使用 <code>git commit</code> 命令将暂存目录的快照提交到存储库的提交历史记录。</p>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p><code>git commit</code> 命令捕获项目当前暂存变更的快照。提交的快照可以被视为项目的“安全”版本——除非您明确要求，否则 Git 永远不会更改它们。快照提交到本地存储库，这完全不需要与其他 Git 存储库进行交互。之后可以将 Git 提交推送到任意远程存储库。</p>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>从高层次上讲，可以将 Git 视为时间线管理实用程序。提交是 Git 项目时间线的核心构建块单元。可以将提交视为 Git 项目时间线上的快照或里程碑。</p>
<h4 id="快照，而不是差异"><a href="#快照，而不是差异" class="headerlink" title="快照，而不是差异"></a>快照，而不是差异</h4><p>除了 SVN 和 Git 之间的实际区别外，它们的底层实现还遵循完全不同的设计理念。SVN 跟踪文件的差异，而 Git 的版本控制模型则基于快照。例如，SVN 提交包含与添加到存储库的原始文件相比的差异。而 Git 会在每次提交中记录每个文件的全部内容。</p>
<img src="/images/image-20230321110255642.png" alt="image-20230321110255642" style="zoom:50%;" />

<p>这使得许多 Git 操作比 SVN 快得多，因为不必从其差异中“汇编”文件的特定版本——每个文件的完整版本可以立即从 Git 的内部数据库中获得。</p>
<h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>比对功能接受两个输入数据集并输出它们之间的变更。<code>git diff</code> 是一个多用途 Git 命令，它在执行时会在 Git 数据源上运行比对功能。</p>
<h2 id="Git-stash"><a href="#Git-stash" class="headerlink" title="Git stash"></a>Git stash</h2><p>git stash临时搁置（或隐藏）您对工作副本所做的更改，这样您就可以处理其他内容，然后再回来重新应用它们。如果你需要快速切换上下文并开始做其他事情，但是你正在进行代码更改并且还没有准备好提交，那么stash功能非常方便。</p>
<p><code>git stash</code> 命令会将当前工作目录中的所有修改（包括已经加入到暂存区域的修改）暂存起来。暂存区域中的修改不会被清除或重置，而是一同被储藏起来。</p>
<h4 id="Stashing-untracked-or-ignored-files"><a href="#Stashing-untracked-or-ignored-files" class="headerlink" title="Stashing untracked or ignored files"></a>Stashing untracked or ignored files</h4><p>默认情况下，运行 <code>git stash</code> 命令会将以下内容储藏起来：</p>
<ul>
<li>已经被加入到暂存区域的修改（即已经被 <code>git add</code> 添加的修改）</li>
<li>当前被 Git 跟踪的文件中所做的修改（即未加入到暂存区域的修改）</li>
</ul>
<p>但是，<code>git stash</code> 命令不会储藏以下内容：</p>
<ul>
<li>工作目录中尚未被加入到暂存区域的新文件</li>
<li>被 Git 忽略的文件</li>
</ul>
<p>如果在 <code>git stash</code> 命令中添加 <code>-u</code> 选项（或 <code>--include-untracked</code>），则会将未被 Git 跟踪的文件也一并储藏起来。这些未被跟踪的文件指的是在 Git 仓库中还没有被添加过的文件，或者是被 <code>.gitignore</code> 文件所忽略的文件。</p>
<img src="/images/image-20230321113434497.png" alt="image-20230321113434497" style="zoom:50%;" />

<h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>Git会将您工作目录中的每个文件视为以下三种情况之一：</p>
<ul>
<li><p>已跟踪（tracked）- 已经被Git跟踪的文件，也就是之前已经被添加到暂存区域或者已经提交过的文件；</p>
</li>
<li><p>未跟踪（untracked）- 没有被添加到暂存区域或者没有被提交过的文件；</p>
</li>
<li><p>被忽略（ignored）- Git已经被明确告知要忽略的文件。</p>
</li>
</ul>
<p>被忽略的文件通常是构建工件和机器生成的文件，这些文件可以从存储库源派生，或者不应该提交。一些常见的例子有：</p>
<ul>
<li>依赖缓存目录，例如 <code>/node_modules</code> 或 <code>/packages</code></li>
<li>编译后的代码，例如 <code>.o</code>，<code>.pyc</code> 和 <code>.class</code> 文件</li>
<li>构建输出目录，例如 <code>/bin</code>，<code>/out</code> 或 <code>/target</code></li>
<li>运行时生成的文件，例如 <code>.log</code>，<code>.lock</code> 或 <code>.tmp</code></li>
<li>隐藏的系统文件，例如 <code>.DS_Store</code> 或 <code>Thumbs.db</code></li>
<li>个人 IDE 配置文件，例如 <code>.idea/workspace.xml</code></li>
</ul>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>:stuck_out_tongue:早建分支！多用分支！</p>
<p>即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p>
<p>使用分支其实就相当于在说：“<strong>我想基于这个提交以及它所有的父提交进行新的工作。</strong>”</p>
<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p>
<h2 id="场景解决"><a href="#场景解决" class="headerlink" title="场景解决"></a>场景解决</h2><blockquote>
<p>你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，然后又提交了一次。</p>
<p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p>
</blockquote>
<p>我们可以通过下面的方法来克服困难：</p>
<ul>
<li>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们<strong>想要修改的提交记录挪到最前</strong></li>
<li>然后用 <code>git commit --amend</code> 来<strong>进行一些小修改</strong></li>
<li>接着再用 <code>git rebase -i</code> 来将他们<strong>调回原来的顺序</strong></li>
<li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li>
</ul>
<blockquote>
<p>正如你在上一关所见到的，我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p>
<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。下面还是看看 <code>git cherry-pick</code> 是怎么做的吧。</p>
</blockquote>
<p>cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题）。</p>
<ul>
<li>git checkout C1</li>
<li>git cherry-pick C2</li>
<li>git commit –amend</li>
<li>git cherry-pick C3</li>
</ul>
<p>相当于重新走一遍</p>
<h2 id="Git-Tags"><a href="#Git-Tags" class="headerlink" title="Git Tags"></a>Git Tags</h2><p>分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p>
<p>有没有什么可以<em>永远</em>指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>
<p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<h2 id="多分支-rebase"><a href="#多分支-rebase" class="headerlink" title="多分支 rebase"></a>多分支 rebase</h2><ul>
<li>rebase -i</li>
<li>rebase</li>
<li>cherry-pick</li>
</ul>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录</p>
<p>话虽如此, 远程仓库却有一系列强大的特性</p>
<ul>
<li>首先也是最重要的的点, 远程仓库是一个<strong>强大的备份</strong>。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</li>
<li>还有就是, <strong>远程让代码社交化了</strong>! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</li>
</ul>
<p>现在用网站来对远程仓库进行可视化操作变得越发流行了(像 <a href="https://github.com/">GitHub</a>), 但远程仓库<strong>永远</strong>是这些工具的顶梁柱, 因此理解其概念非常的重要!</p>
<h4 id="git-clone-1"><a href="#git-clone-1" class="headerlink" title="git clone"></a>git clone</h4><p>使用<code>git clone</code> 命令了，咱们深入地看一下发生了什么。</p>
<p>你可能注意到的第一个事就是在我们的本地仓库多了一个名为 <code>o/main</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p>
<p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p>
<p>远程分支有一个特别的属性，在你checkout时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, <strong>（更新了远程分支之后）再用远程分享你的工作成果。</strong></p>
<h4 id="Git-Fetch"><a href="#Git-Fetch" class="headerlink" title="Git Fetch"></a>Git Fetch</h4><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p>
<p>本节课我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是 <code>git fetch</code>。</p>
<p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p>
<ul>
<li>从远程仓库下载本地仓库中缺失的提交记录</li>
<li>更新远程分支指针(如 <code>o/main</code>)</li>
</ul>
<p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。所以, 你可以将 <code>git fetch</code> 的理解为单纯的下载操作。</p>
<h2 id="Git-Pull"><a href="#Git-Pull" class="headerlink" title="Git Pull"></a>Git Pull</h2><p>如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p>
<p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p>
<ul>
<li><code>git cherry-pick o/main</code></li>
<li><code>git rebase o/main</code></li>
<li><code>git merge o/main</code></li>
<li>等等</li>
</ul>
<p>实际上，<strong>由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</strong></p>
<p><code>git pull</code> 就是 git fetch 和 git merge 的缩写！</p>
<h2 id="Git-Push"><a href="#Git-Push" class="headerlink" title="Git Push"></a>Git Push</h2><p>上传自己分享内容与下载他人的分享刚好相反，那与 <code>git pull</code> 相反的命令是什么呢？<code>git push</code>！</p>
<h2 id="历史偏离"><a href="#历史偏离" class="headerlink" title="历史偏离"></a>历史偏离</h2><blockquote>
<p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p>
<p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行 <code>git push</code>，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p>
<p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 <code>push</code> 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>
</blockquote>
<ul>
<li>git pull –rebase</li>
<li>git pull                       # merge</li>
</ul>
<h2 id="远程服务器拒绝-Remote-Rejected"><a href="#远程服务器拒绝-Remote-Rejected" class="headerlink" title="远程服务器拒绝!(Remote Rejected)"></a>远程服务器拒绝!(Remote Rejected)</h2><blockquote>
<p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</span><br></pre></td></tr></table></figure>

<p>远程服务器拒绝直接推送(push)提交到main, 因为策略配置要求 pull requests 来提交更新.</p>
<p>你应该按照流程,新建一个分支, 推送(push)这个分支并<strong>申请pull request</strong>, 但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.</p>
</blockquote>
<p>新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.</p>
<h2 id="为什么不用-merge-呢"><a href="#为什么不用-merge-呢" class="headerlink" title="为什么不用 merge 呢?"></a>为什么不用 merge 呢?</h2><p>为了 push 新变更到远程仓库，你要做的就是<strong>包含</strong>远程仓库中最新变更。意思就是只要你的本地分支包含了远程分支（如 <code>o/main</code>）中的最新变更就可以了，至于具体是用 rebase 还是 merge，并没有限制。</p>
<p>那么既然没有规定限制，为何前面几节都在着重于 rebase 呢？为什么在操作远程分支时不喜欢用 <code>merge</code> 呢？</p>
<p>在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：</p>
<p>优点:</p>
<ul>
<li><strong>Rebase 使你的提交树变得很干净, 所有的提交都在一条线上</strong></li>
</ul>
<p>缺点:</p>
<ul>
<li>Rebase <strong>修改了提交树的历史</strong></li>
</ul>
<p>比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，<strong>但实际上是在 C3 之前</strong>。</p>
<p>一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能<strong>更喜欢干净的提交树</strong>，于是偏爱 rebase。仁者见仁，智者见智。 :D</p>
<h2 id="远程跟踪"><a href="#远程跟踪" class="headerlink" title="远程跟踪"></a>远程跟踪</h2><p>直接了当地讲，<code>main</code> 和 <code>o/main</code> 的关联关系就是由分支的“remote tracking”属性决定的。<code>main</code> 被设定为跟踪 <code>o/main</code> —— 这意味着为 <code>main</code> 分支<strong>指定了推送的目的地以及拉取后合并的目标。</strong></p>
<p>你可能想知道 <code>main</code> 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。</p>
<p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 <code>o/main</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 <code>main</code>。</p>
<p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p>
<p>这也解释了为什么会在克隆的时候会看到下面的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local branch &quot;main&quot; set to track remote branch &quot;o/main&quot;</span><br></pre></td></tr></table></figure>





































]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Code review in Golang</title>
    <url>/2023/03/21/Code-review-in-Golang/</url>
    <content><![CDATA[<h2 id="Code-review-in-Golang"><a href="#Code-review-in-Golang" class="headerlink" title="Code review in Golang"></a>Code review in Golang</h2><p>ref: <a href="https://github.com/golang/go/wiki/CodeReviewComments">https://github.com/golang/go/wiki/CodeReviewComments</a></p>
<h4 id="Gofmt"><a href="#Gofmt" class="headerlink" title="Gofmt"></a>Gofmt</h4><p>运行 <code>gofmt</code> 可以自动修复大部分机械风格问题。几乎所有在外部使用的 Golang 代码都使用 <code>gofmt</code> 进行<strong>格式化</strong>。</p>
<h4 id="Comment-Sentences"><a href="#Comment-Sentences" class="headerlink" title="Comment Sentences"></a>Comment Sentences</h4><p>记录声明的注释，应该使用完整的句子。这种方法使得当将它们提取到 godoc 文档中时，它们的格式很好。<strong>注释应该以被描述的事物名称开头，并以句号结束</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Request represents a request to run a command.</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123; ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode writes the JSON encoding of req to w.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(w io.Writer, req *Request)</span></span> &#123; ...</span><br></pre></td></tr></table></figure>

<h4 id="Contexts"><a href="#Contexts" class="headerlink" title="Contexts"></a>Contexts</h4><p><code>context.Context</code> 类型的值在 API 和进程边界之间携带安全凭证、跟踪信息、截止时间和取消信号。Go 程序会将 Contexts 在整个函数调用链中显式传递，从传入的 RPC 和 HTTP 请求到传出的请求。</p>
<p>大多数使用 Context 的函数应将其作为<strong>第一个参数接受</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">(ctx context.Context, /* other arguments */)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>一个从不特定于请求的函数可以使用 <code>context.Background()</code>，但即使您认为不需要，也要尽量传递一个 Context。默认情况下是传递一个 Context；只有在确有充分理由认为替代方案是错误的情况下，才直接使用 <code>context.Background()</code>。</p>
<p><strong>不要将 Context 成员添加到结构类型中</strong>；相反，为该类型上每个需要传递它的方法添加一个 ctx 参数。唯一的例外是那些签名必须与标准库或第三方库中的接口匹配的方法。</p>
<p>不要创建自定义 Context 类型或在函数签名中使用除 Context 以外的接口。</p>
<p>如果您有应用程序数据需要传递，将其放在参数中、接收器中、全局变量中，或者，如果它确实属于那里，放在 Context 值中。</p>
<p>Contexts 是<strong>不可变</strong>的，因此将相同的 ctx 传递给多个共享相同截止时间、取消信号、凭证、父跟踪等的调用是可以的。</p>
<h4 id="Copying"><a href="#Copying" class="headerlink" title="Copying"></a>Copying</h4><p>为避免意外的别名问题，在从另一个包中复制结构体时要小心。例如，bytes.Buffer 类型包含一个 []byte 切片。如果您复制一个 Buffer，副本中的切片可能会别名原始数组，导致后续的方法调用产生令人惊讶的效果。</p>
<p>通常情况下，如果类型 T 的方法与指针类型 *T 相关联，则不要复制类型 T 的值。</p>
<p>举例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个 bytes.Buffer 类型的实例</span></span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向 buf 中写入数据</span></span><br><span class="line">	buf.WriteString(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复制 buf</span></span><br><span class="line">	bufCopy := buf</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分别在原始 buf 和复制的 bufCopy 上调用方法</span></span><br><span class="line">	buf.WriteByte(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">	bufCopy.WriteByte(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印两个缓冲区的内容</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Original buffer: %s\n&quot;</span>, buf.String())   <span class="comment">// 输出: Original buffer: Hello, world!B</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Copied buffer: %s\n&quot;</span>, bufCopy.String()) <span class="comment">// 输出: Copied buffer: Hello, world!B</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 我们本来期望从 buf 中读取 &quot;Hello, world!A&quot;，但是结果却是 &quot;Hello, world!B&quot;。这是因为 buf 和 bufCopy 的底层数组共享同一内存，导致调用方法时产生了意外的效果。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Go 语言中，当我们直接将一个结构体赋值给另一个结构体时，实际上进行的是值复制。这意味着结构体中的每个字段都会被逐一复制到新的结构体中。对于简单类型（例如 int、float、bool 等）和数组，复制操作会创建新的数据副本。<strong>然而，对于切片（slice）和引用类型（如指针、映射和通道），复制操作仅复制它们的引用，而不会复制底层数据</strong>。</p>
<p>在本例中，<code>bytes.Buffer</code> 类型包含一个 <code>[]byte</code> 切片。当我们直接复制 <code>bytes.Buffer</code> 时，<strong>它的底层数组并没有被复制，而只是复制了指向该底层数组的切片引用</strong>。因此，**<code>buf</code> 和 <code>bufCopy</code> 实际上共享同一块底层内存**。在这种情况下，对其中一个 <code>bytes.Buffer</code> 实例进行的任何更改都会影响另一个实例，从而导致意外的行为。</p>
<p>要理解这一点，可以将切片想象成一个具有三个字段的结构体：一个指向底层数组的指针、一个表示切片长度的整数和一个表示切片容量的整数。当我们复制一个包含切片的结构体时，实际上复制的是这三个字段。因此，新切片和原切片指向的是相同的底层数组，它们共享相同的内存。</p>
</blockquote>
<h4 id="Crypto-Rand"><a href="#Crypto-Rand" class="headerlink" title="Crypto Rand"></a>Crypto Rand</h4><p>不要使用 math&#x2F;rand 包来生成密钥，即使是一次性的密钥也不行。未使用种子时，<strong>生成器是完全可预测的</strong>。使用 time.Nanoseconds() 作为种子时，<strong>只有几个比特的熵</strong>。相反，应该使用 crypto&#x2F;rand 的 Reader，如果需要文本，则可以将其打印为十六进制或 base64 格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="comment">// &quot;encoding/base64&quot;</span></span><br><span class="line">	<span class="comment">// &quot;encoding/hex&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Key</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">16</span>)</span><br><span class="line">	_, err := rand.Read(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err) <span class="comment">// out of randomness, should never happen</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, buf)</span><br><span class="line">	<span class="comment">// or hex.EncodeToString(buf)</span></span><br><span class="line">	<span class="comment">// or base64.StdEncoding.EncodeToString(buf)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Declaring-Empty-Slices"><a href="#Declaring-Empty-Slices" class="headerlink" title="Declaring Empty Slices"></a>Declaring Empty Slices</h4><p>在声明一个空切片时，应该优先使用</p>
<p><code>var t []string </code> 而不是  <code>t := []string&#123;&#125;</code></p>
<p>前者声明了一个 <strong>nil 切片值</strong>，而后者是一个非 nil 但长度为零的切片。它们在功能上是等效的——它们的 len 和 cap 都为零——但是 nil 切片是首选的风格。</p>
<p>需要注意的是，在某些有限的情况下，非 nil 但长度为零的切片是首选的，例如编码 JSON 对象时（nil 切片编码为 null，而 []string{} 编码为 JSON 数组 []）。</p>
<p>在设计接口时，应避免将 nil 切片和非 nil、长度为零的切片区分开来，因为这可能会导致微妙的编程错误。</p>
<p>有关 Go 中 nil 的更多讨论，请参见 Francesc Campoy 的演讲 <a href="https://www.youtube.com/watch?v=ynoY2xz-F8s">Understanding Nil</a>.</p>
<h4 id="Don’t-Panic"><a href="#Don’t-Panic" class="headerlink" title="Don’t Panic"></a>Don’t Panic</h4><p>不要将 panic 用于正常的错误处理。使用 error 和多个返回值。</p>
<p>通常情况下，当函数或方法遇到错误时，应该返回一个错误值，而不是抛出一个异常或使用 panic。这样可以使代码更加健壮和可靠，因为它允许代码在遇到错误时进行适当的处理，而不是在程序崩溃时才发现问题。</p>
<h4 id="Error-Strings"><a href="#Error-Strings" class="headerlink" title="Error Strings"></a>Error Strings</h4><p>错误字符串不应该大写（除非以专有名词或缩写词开头），也不应该以标点符号结尾，因为它们通常是在其他上下文中打印的。也就是说，应该使用 fmt.Errorf(“something bad”) 而不是 fmt.Errorf(“Something bad”)，这样 log.Printf(“Reading %s: %v”, filename, err) 就可以格式化成一个无意义的大写字母中间消息。这不适用于日志记录，因为日志记录隐含是基于行的，不会与其他消息合并在一起。</p>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><p>添加新 package 时，请包括预期用途的示例：可运行的示例，或演示完整调用序列的简单测试。</p>
<h4 id="Goroutine-Lifetimes"><a href="#Goroutine-Lifetimes" class="headerlink" title="Goroutine Lifetimes"></a>Goroutine Lifetimes</h4><p>当你启动 goroutine 时，<strong>要清楚它们何时（或是否）退出</strong>。</p>
<p>goroutine 会因为在<strong>通道发送或接收时阻塞</strong>而泄露：<strong>即使它所阻塞的通道不可达，垃圾回收器也不会终止一个 goroutine</strong>。</p>
<p>即使 goroutine 没有泄露，让它们在不再需要时仍处于执行状态可能会导致其他微妙且难以诊断的问题。<strong>在关闭的通道上发送消息会引发 panic</strong>。并且让 goroutine 长时间处于执行状态可能会导致不可预测的内存使用。</p>
<p>尽量<strong>让并发代码简单明了</strong>，<strong>以便 goroutine 的生命周期显而易见</strong>。如果这不可行，就要<strong>记录 goroutine 退出的时间和原因</strong>。</p>
<h4 id="Handle-Errors"><a href="#Handle-Errors" class="headerlink" title="Handle Errors"></a>Handle Errors</h4><p>不要使用 _ 变量丢弃错误。如果一个函数返回一个错误，<strong>要检查它以确保函数成功执行</strong>。要处理错误、返回错误，<strong>或者在真正异常的情况下使用 panic</strong>。</p>
<h4 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h4><p>除非需要避免名称冲突，否则应避免重命名导入；良好的包名称不应需要重命名。在<strong>发生冲突的情况下，优先重命名最本地或项目特定的导入</strong>。</p>
<p>导入应该组织在组中，并在它们之间有空白行。标准库的包始终在第一组中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hash/adler32&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/foo/bar&quot;</span></span><br><span class="line">	<span class="string">&quot;rsc.io/goversion/version&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><a href="https://pkg.go.dev/golang.org/x/tools/cmd/goimports">goimports</a> will do this for you.</p>
<h4 id="Import-Blank"><a href="#Import-Blank" class="headerlink" title="Import Blank"></a>Import Blank</h4><p>仅为了副作用（我们只是希望该包中的代码能够执行一些副作用，例如注册一个 HTTP 处理器或者执行一些<strong>初始化逻辑</strong>。）而导入的包（使用语法 import _ “pkg”）应该只在程序的 <strong>main 包</strong>或需要它们的测试中被导入。</p>
<h4 id="Go-modules简单使用"><a href="#Go-modules简单使用" class="headerlink" title="Go modules简单使用"></a>Go modules简单使用</h4><ul>
<li>打开包含 <code>go.mod</code> 文件的文件夹作为工作区</li>
<li>使用模块路径：<code>&quot;tytao.com/example/bar/testutil&quot;</code> 而不是  <code>&quot;bar/testutil&quot;</code></li>
</ul>
<h4 id="In-Band-Errors"><a href="#In-Band-Errors" class="headerlink" title="In-Band Errors"></a>In-Band Errors</h4><p>在 C 和类似的语言中，函数常常会返回像 -1 或 null 这样的值来表示错误或缺少结果。</p>
<p>Go 支持<strong>多返回值</strong>提供了更好的解决方案。函数不应该要求客户端检查内部错误值，而是应该<strong>返回一个额外的值来指示其它返回值是否有效</strong>。这个返回值可以是一个错误，或者当不需要解释时可以是一个布尔值。它应该是最后一个返回值。</p>
<h4 id="Indent-Error-Flow"><a href="#Indent-Error-Flow" class="headerlink" title="Indent Error Flow"></a>Indent Error Flow</h4><p>尽量将正常的代码路径<strong>保持在最小缩进</strong>，将错误处理缩进处理，首先处理它。这通过允许快速扫描正常路径来提高代码的可读性。例如，不要写成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// normal code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Instead, write:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// error handling</span></span><br><span class="line">	<span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br></pre></td></tr></table></figure>

<h4 id="Initialisms"><a href="#Initialisms" class="headerlink" title="Initialisms"></a>Initialisms</h4><p>在名称中表示缩写或首字母缩写词的单词（例如 “URL” 或 “NATO”）应该具有一致的大小写。例如，”URL” 应该出现为 “URL” 或 “url”（例如 “urlPony” 或 “URLPony”），而不应该出现为 “Url”。例如：ServeHTTP 而不是 ServeHttp。对于有多个首字母缩写词的标识符，例如 “xmlHTTPRequest” 或 “XMLHTTPRequest”。</p>
<p>当 “ID” 缩写代表 “identifier” 时（除了 “id” 代表 “自我”、”超我” 等的情况），此规则也适用，因此应该写成 “appID” 而不是 “appId”。</p>
<p>由协议缓冲区编译器生成的代码不受此规则的约束。人工编写的代码应该比机器生成的代码更加严格。</p>
<h4 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h4><p>通常情况下，<strong>Go 接口应该属于使用接口类型值的包，而不是实现这些值的包</strong>。实现包应该返回具体的类型（通常是指针或结构体类型）：这样就可以在不需要进行大量重构的情况下向实现中添加新的方法。</p>
<p><strong>不要在 API 的实现方定义接口</strong> “用于模拟”；相反，设计 API 使得可以使用真实实现的公共 API 进行测试。</p>
<p><strong>不要在使用前定义接口</strong>：如果没有实际的使用示例，那么很难判断是否需要接口，更不用说需要包含哪些方法了。</p>
<p>也就是说，实现package中用具体类型，使用时用接口。</p>
<h4 id="Line-Length"><a href="#Line-Length" class="headerlink" title="Line Length"></a>Line Length</h4><p>在 Go 代码中没有严格的行长度限制，但应避免过长的行。同样地，不要添加换行符来保持行的短小，如果它们长而更易读的话，例如重复的代码。</p>
<p>大多数情况下，当人们在函数调用或函数声明的中间 “不自然” 地换行时，如果它们有合理数量的参数和合理长度的变量名，这种换行是不必要的。长行似乎与长变量名有关，<strong>去掉长变量名</strong>可以起到很大的帮助作用。</p>
<p>换句话说，根据你<strong>正在编写的语义换行</strong>（作为一般规则），而不是因为行的长度。如果发现这导致行太长，那么改变名称或语义可能会得到一个好结果。</p>
<p>实际上，这正是有关函数长度的建议。没有规则 “永远不要让函数超过 N 行”，但肯定有过长的函数和过于重复的微小函数，解决方法是<strong>改变函数边界的位置</strong>，而不是开始计算行数。</p>
<h4 id="Named-Result-Parameters"><a href="#Named-Result-Parameters" class="headerlink" title="Named Result Parameters"></a>Named Result Parameters</h4><p>在编写 godoc 时要考虑函数的外观。有些情况，有名的结果参数会显得重复：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Parent2() (node *Node, err <span class="type">error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>最好使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Parent2() (*Node, <span class="type">error</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然而，如果一个函数返回两个或三个相同类型的参数，或者如果结果的含义从上下文中不清楚，添加名称在某些情况下可能是有用的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span></span> Location() (<span class="type">float64</span>, <span class="type">float64</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>最好使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Location 返回 f 的纬度和经度。</span></span><br><span class="line"><span class="comment">// 负值分别表示南纬和西经。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Foo)</span></span> Location() (lat, long <span class="type">float64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Naked-Returns"><a href="#Naked-Returns" class="headerlink" title="Naked Returns"></a>Naked Returns</h4><p>一个不带参数的返回语句会返回命名的返回值。这被称为 “裸返回”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">	x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">	y = sum - x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Package-Comments"><a href="#Package-Comments" class="headerlink" title="Package Comments"></a>Package Comments</h4><p>包注释，就像所有要在 godoc 中显示的注释一样，必须紧邻着包声明语句出现，不能有空行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package math provides basic constants and mathematical functions.</span></span><br><span class="line"><span class="keyword">package</span> math</span><br></pre></td></tr></table></figure>

<h4 id="Package-Names"><a href="#Package-Names" class="headerlink" title="Package Names"></a>Package Names</h4><p>在你的包中，<strong>所有对名称的引用都将使用包名，因此你可以省略标识符中的包名</strong>。例如，如果你在包 chubby 中，你不需要定义类型 ChubbyFile，客户端将会写成 chubby.ChubbyFile。相反，可以将该类型命名为 File，客户端将会写成 chubby.File。避免使用毫无意义的包名，如 util、common、misc、api、types 和 interfaces。更多信息请参见 <a href="https://go.dev/doc/effective_go#package-names">https://go.dev/doc/effective_go#package-names</a> 和 <a href="https://go.dev/blog/package-names%E3%80%82">https://go.dev/blog/package-names。</a></p>
<h4 id="Pass-Values"><a href="#Pass-Values" class="headerlink" title="Pass Values"></a>Pass Values</h4><p><strong>不要仅仅为了节省几个字节而将指针作为函数参数传递</strong>。如果一个函数只是通过 <code>*x</code> 来引用它的参数 <code>x</code>，那么该参数就不应该是一个指针。这种情况的常见实例包括传递一个字符串的指针 (<code>*string</code>) 或一个接口值的指针 (<code>*io.Reader</code>)。<strong>在这两种情况下，值本身是固定大小的，可以直接传递</strong>。<strong>这个建议不适用于大的结构体，甚至是可能增长的小的结构体</strong>。</p>
<p>也就是说，推荐使用值传递。</p>
<h4 id="Receiver-Names"><a href="#Receiver-Names" class="headerlink" title="Receiver Names"></a>Receiver Names</h4><p>方法的接收者的名称应该<strong>反映其身份</strong>；通常一个类型的一个或两个字母的缩写就足够了（例如 “c” 或 “cl” 表示 “Client”）。不要使用通用名称，如 “me”、”this” 或 “self”，这些标识符是面向对象语言的典型标识符，给方法赋予了特殊的含义。<strong>在 Go 中</strong>，<strong>方法的接收者只是另一个参数，因此应该相应地命名</strong>。接收者的名称不必像方法参数那样具有描述性，因为它的作用是显而易见的，没有文档目的。名称可以非常短，因为它将出现在类型的每个方法的几乎每一行代码中；熟悉可以缩短长度。也要保持一致：如果在一个方法中将接收者称为 “c”，则在另一个方法中不要将其称为 “cl”。</p>
<h4 id="Receiver-Type"><a href="#Receiver-Type" class="headerlink" title="Receiver Type"></a>Receiver Type</h4><p>对于方法<strong>是否使用值接收者或指针接收者的选择可能很困难</strong>，尤其<strong>对于新手来说。如果不确定，使用指针</strong>，但有时候值接收者更加合理，通常是出于效率的原因，例如对于小的不可变结构体或基本类型的值。以下是一些有用的指南：</p>
<ul>
<li>如果接收者是 map、func 或 chan，不要使用它们的指针。如果接收者是 slice，并且方法不会重新分配或重新分片 slice，则不要使用它的指针。</li>
<li>如果方法<strong>需要修改接收者，接收者必须是指针</strong>。</li>
<li>如果接收者是<strong>包含 sync.Mutex 或类似同步字段的结构体，则接收者必须是指针</strong>，以避免复制。</li>
<li>如果接收者是大型结构体或数组，则指针接收者更有效率。多大才算大？假设它相当于将所有元素作为参数传递给方法。如果感觉太大了，接收者也太大了。</li>
<li>函数或方法是否可以在并发时或从此方法调用时修改接收者？值类型在调用方法时创建接收者的副本，因此外部更新不会应用于此接收者。如果必须在原始接收者中看到更改，则接收者必须是指针。</li>
<li>如果接收者是结构体、数组或切片，并且其中任何一个元素是指向可能<strong>发生变化</strong>的东西的指针，那么最好使用指针接收者，因为这将使意图更清晰。</li>
<li>如果接收者是一个小的数组或结构体，自然是一个值类型（例如 time.Time 类型），没有可变的字段和指针，或者只是一个简单的基本类型，如 int 或 string，则值接收者是有意义的。<strong>值接收者可以减少可能产生的垃圾量；如果将一个值传递给值方法，则可以使用栈上的副本而不是在堆上分配。</strong>编译器试图聪明地避免这种分配，但不总是成功。<strong>不要在没有进行性能分析的情况下出于这个原因选择值接收者类型</strong>。</li>
<li><strong>不要混合使用接收者类型</strong>。对所有可用方法选择指针或结构体类型。</li>
<li>最后，<strong>如果不确定，请使用指针接收者</strong>。</li>
</ul>
<h4 id="Synchronous-Functions"><a href="#Synchronous-Functions" class="headerlink" title="Synchronous Functions"></a>Synchronous Functions</h4><p>建议优先选择<strong>同步函数</strong> - 即在返回结果之前直接返回或完成任何回调或通道操作的函数。</p>
<p>同步函数可以将 goroutine <strong>限定在一个调用中，使得更容易理解它们的生命周期并避免泄漏和数据竞争</strong>。它们也更容易进行测试：调用者可以传递输入并检查输出，<strong>而无需进行轮询或同步</strong>。</p>
<p>如果<strong>调用者需要更多并发性</strong>，他们可以轻松地通过<strong>从单独的 goroutine 中调用该函数</strong>来实现。但是，在调用者端删除不必要的并发性通常是相当困难甚至不可能的。</p>
<p>也就是说，函数尽量写成同步的，调用时可以方便的控制并发量。</p>
<h4 id="Useful-Test-Failures"><a href="#Useful-Test-Failures" class="headerlink" title="Useful Test Failures"></a>Useful Test Failures</h4><p>测试应该以有用的错误信息失败，说明出了什么问题，使用了什么输入，实际得到了什么，期望得到了什么。可能会想编写一堆 assertFoo 辅助函数，<strong>但要确保这些函数产生有用的错误信息</strong>。假设调试失败的测试的人不是你，也不是你的团队。一个典型的 Go 测试失败如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> got != tt.want &#123;</span><br><span class="line">	t.Errorf(<span class="string">&quot;Foo(%q) = %d; want %d&quot;</span>, tt.in, got, tt.want) <span class="comment">// 或者使用 Fatalf，如果测试不能测试此点以外的任何内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>请注意，这里的顺序是<strong>实际结果 !&#x3D; 期望结果</strong>，错误消息也使用该顺序。一些测试框架鼓励将它们写反：0 !&#x3D; x，”期望得到 0，实际得到 x”等等。但 Go 不是这样的。</p>
<p>如果感觉这样打字太多了，可以考虑编写<strong>表驱动测试</strong>。</p>
<p>另一种常见的技术是在使用不同输入的测试助手时，使用不同的 TestFoo 函数包装每个调用，这样测试失败时会显示该名称：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSingleValue</span><span class="params">(t *testing.T)</span></span> &#123; testHelper(t, []<span class="type">int</span>&#123;<span class="number">80</span>&#125;) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNoValues</span><span class="params">(t *testing.T)</span></span> &#123; testHelper(t, []<span class="type">int</span>&#123;&#125;) &#125;</span><br></pre></td></tr></table></figure>


<p>无论如何，你需要为将来调试你的代码的人<strong>提供有用的失败信息</strong>。</p>
<h4 id="Variable-Names"><a href="#Variable-Names" class="headerlink" title="Variable Names"></a>Variable Names</h4><p>Go 中的变量名应该是简短的而不是长的。这对于具有<strong>有限作用域的局部变量</strong>尤其如此。应该优先选择 c 而不是 lineCount。应该优先选择 i 而不是 sliceIndex。</p>
<p><strong>基本规则是：距离其声明越远的地方使用的名称，名称越需要详细描述。</strong>对于方法接收器，一个或两个字母就足够了。常见的变量，如循环索引和读取器，可以使用单个字母（i、r）。更不寻常的事物和全局变量需要更详细的名称。</p>
<p>另请参见 <a href="https://google.github.io/styleguide/go/decisions#variable-names">the Google Go Style Guide</a>中的更长讨论。</p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang: What&#39;s in a name?</title>
    <url>/2023/03/22/Golang-What-s-in-a-name/</url>
    <content><![CDATA[<h2 id="What’s-in-a-name"><a href="#What’s-in-a-name" class="headerlink" title="What’s in a name?"></a>What’s in a name?</h2><h4 id="名称很重要"><a href="#名称很重要" class="headerlink" title="名称很重要"></a>名称很重要</h4><p>可读性是良好代码的定义特性。好的名称对于可读性至关重要。这次讲话是关于 Go 中的命名。</p>
<blockquote>
<h3 id="Good-names"><a href="#Good-names" class="headerlink" title="Good names"></a>Good names</h3></blockquote>
<ul>
<li>Consistent (易于猜测),</li>
<li>Short (易于输入),</li>
<li>Accurate (易于理解).</li>
</ul>
<h4 id="一个经验法则"><a href="#一个经验法则" class="headerlink" title="一个经验法则"></a>一个经验法则</h4><p>名称的声明和使用之间的距离越远，名称就应该越长。</p>
<p>因为需要能只看名字就能知道变量的含义。</p>
<h4 id="使用-MixedCase"><a href="#使用-MixedCase" class="headerlink" title="使用 MixedCase"></a>使用 MixedCase</h4><p>Go 中的名称应该使用 MixedCase。</p>
<p>（不要使用 names_with_underscores。）</p>
<p><strong>缩写词应该全部大写</strong>，例如 ServeHTTP 和 IDProcessor。</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>将它们保持简短；长名称会使代码的含义变得模糊。</p>
<ul>
<li><p>常见的变量&#x2F;类型组合可能会使用非常短的名称：优先选择 i 而不是 index；优先选择 r 而不是 reader；优先选择 b 而不是 buffer。</p>
</li>
<li><p>避免冗余的名称，考虑到它们的上下文：在名为 RuneCount 的函数内部，优先选择 count 而不是 runeCount。</p>
</li>
<li><p>在语句 v, ok :&#x3D; m[k] 中，优先选择 ok 而不是 keyInMap。</p>
</li>
</ul>
<p>长名称可能有助于<strong>长函数</strong>或具有许多局部变量的函数。<br>（但通常这意味着你应该进行重构。）</p>
<blockquote>
<h3 id="Bad"><a href="#Bad" class="headerlink" title="Bad"></a>Bad</h3></blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneCount</span><span class="params">(buffer []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    runeCount := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="built_in">len</span>(buffer); &#123;</span><br><span class="line">        <span class="keyword">if</span> buffer[index] &lt; RuneSelf &#123;</span><br><span class="line">            index++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _, size := DecodeRune(buffer[index:])</span><br><span class="line">            index += size</span><br><span class="line">        &#125;</span><br><span class="line">        runeCount++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> runeCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="Good"><a href="#Good" class="headerlink" title="Good"></a>Good</h3></blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneCount</span><span class="params">(b []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); &#123;</span><br><span class="line">        <span class="keyword">if</span> b[i] &lt; RuneSelf &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _, n := DecodeRune(b[i:])</span><br><span class="line">            i += n</span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h4><p>函数参数就像局部变量一样，但它们也作为文档说明。</p>
<p>如果类型是描述性的，则应该使用简短的名称：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span></span>) *Timer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Escape</span><span class="params">(w io.Writer, s []<span class="type">byte</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>如果类型更加模糊，则名称可以提供说明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unix</span><span class="params">(sec, nsec <span class="type">int64</span>)</span></span> Time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix []<span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<h4 id="Return-values"><a href="#Return-values" class="headerlink" title="Return values"></a>Return values</h4><p>导出函数的返回值只应命名以进行文档说明。</p>
<p>以下是命名返回值的好例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanBytes</span><span class="params">(data []<span class="type">byte</span>, atEOF <span class="type">bool</span>)</span></span> (advance <span class="type">int</span>, token []<span class="type">byte</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Receivers"><a href="#Receivers" class="headerlink" title="Receivers"></a>Receivers</h4><p>接收器是一种特殊类型的参数。</p>
<p>按照惯例，它们是反映接收器类型的一个或两个字符，因为它们通常出现在几乎每一行代码中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span></span> ServeHTTP(rw ResponseWriter, req *Request)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Size() Point</span><br></pre></td></tr></table></figure>

<p>接收器的名称应该在类型的所有方法中保持一致。（不要在一个方法中使用 r，在另一个方法中使用 rdr。）</p>
<h4 id="Exported-package-level-names"><a href="#Exported-package-level-names" class="headerlink" title="Exported package-level names"></a>Exported package-level names</h4><p>导出的名称由它们的包名限定。</p>
<p>在为导出的变量、常量、函数和类型命名时，请记住这一点。</p>
<p>这就是为什么我们有 <code>bytes.Buffer</code> 和 <code>strings.Reader</code>，而不是 <code>bytes.ByteBuffer</code> 和 <code>strings.StringReader</code>。</p>
<p>也就是说，有包名在前面，那包里面的命名就不用一直加前缀了。</p>
<h4 id="Interface-Types"><a href="#Interface-Types" class="headerlink" title="Interface Types"></a>Interface Types</h4><p>只指定一个方法的接口通常只是该函数名称加上 ‘er’ 后缀。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时结果并不是正确的英语，但我们仍然这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Execer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Exec(query <span class="type">string</span>, args []Value) (Result, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时我们使用英语使其更好：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteReader <span class="keyword">interface</span> &#123;</span><br><span class="line">	ReadByte() (c <span class="type">byte</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个接口包含多个方法时，选择一个准确描述其目的的名称（例如：net.Conn、http.ResponseWriter、io.ReadWriter）。</p>
<h4 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h4><p>错误类型应该采用 FooError 的形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ExitError <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误值应该采用 ErrFoo 的形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrFormat = errors.New(<span class="string">&quot;image: unknown format&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h4><p>选择能为导出的名称赋予含义的包名。</p>
<p>避免使用 util、common 等无意义的名称。</p>
<h4 id="Import-paths"><a href="#Import-paths" class="headerlink" title="Import paths"></a>Import paths</h4><p>包路径的最后一个组成部分应该与包名相同。</p>
<p><code>&quot;compress/gzip&quot;</code> &#x2F;&#x2F; 包名为 gzip<br>在仓库和包路径中避免口吃：</p>
<p><code>&quot;code.google.com/p/goauth2/oauth2&quot;</code> &#x2F;&#x2F; 不好的例子；我的错<br>对于库，将包代码放在存储库根目录中通常是可行的：</p>
<p><code>&quot;github.com/golang/oauth2&quot;</code> &#x2F;&#x2F; 包名为 oauth2<br>还应避免使用大写字母（并非所有文件系统都区分大小写）。</p>
<h4 id="The-standard-library"><a href="#The-standard-library" class="headerlink" title="The standard library"></a>The standard library</h4><p>标准库是寻找优秀的 Go 代码的好地方。可以从中获取灵感。</p>
<p>但是需要注意：当编写标准库时，我们仍在学习。大部分都是正确的，但我们也犯了一些错误。</p>
<h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><ul>
<li><p>使用短名称。</p>
</li>
<li><p>考虑上下文。</p>
</li>
<li><p>根据自己的判断。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Concurrency Is Not Parallelism</title>
    <url>/2023/03/22/Concurrency-Is-Not-Parallelism/</url>
    <content><![CDATA[<h2 id="Concurrency-is-not-Parallelism"><a href="#Concurrency-is-not-Parallelism" class="headerlink" title="Concurrency is not Parallelism"></a>Concurrency is not Parallelism</h2><p>“Concurrency is not Parallelism” 是 Rob Pike 在 2012 年的一个著名演讲。在这次演讲中，Rob Pike 详细解释了并发（Concurrency）和并行（Parallelism）之间的区别，以及 Go 语言如何利用并发来提高程序性能。</p>
<h4 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h4><ul>
<li>并发（Concurrency）是独立任务之间的组织和调度方式，它关注的是<strong>如何把问题分解成许多可以独立解决的子问题</strong>。并发关注的是<strong>程序结构</strong>。</li>
<li>并行（Parallelism）是计算机同时执行多个任务的能力。它关注的是在<strong>同一时间内执行多个任务</strong>。并行关注的是<strong>程序执行</strong>。</li>
</ul>
<p>并发并不意味着一定要并行执行。并发可以在单核处理器上实现，通过任务调度和时间片轮转等技术，使得任务看似在同一时间运行，实际上是快速切换执行。</p>
<p>Rob Pike 强调，<strong>Go 语言的设计目标之一是使得程序员能够更容易地编写并发程序</strong>。<strong>Go 通过 goroutines 和 channels 提供了简洁的并发原语</strong>，使得程序员可以轻松地表达并发概念，而<strong>不需要关心底层的线程和锁等细节</strong>。</p>
<h4 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h4><p>Goroutines 是 Go 语言中的<strong>轻量级线程</strong>，它们相<strong>比于传统的操作系统线程，具有更低的创建和管理开销</strong>。<strong>Go 语言运行时会自动处理 goroutines 之间的调度和同步</strong>。</p>
<h4 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h4><p>Channels 是 Go 语言中的一种通信机制，它们允许在不同的 goroutines 之间传递数据。<strong>Channels 可以帮助程序员避免复杂的锁和共享内存的同步问题</strong>。Go 语言的一个**核心理念是 “不要通过共享内存来通信，而要通过通信来共享内存”**。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(prefix <span class="type">string</span>, n <span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		sum += fib(i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s: %d\n&quot;</span>, prefix, sum)</span><br><span class="line">	ch &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="number">10</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		sum(<span class="string">&quot;Fibonacci Sum&quot;</span>, n, ch)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		sum(<span class="string">&quot;Fibonacci Square Sum&quot;</span>, n*<span class="number">2</span>, ch)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">	totalSum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> result := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		totalSum += result</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Total Sum: %d\n&quot;</span>, totalSum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用 <code>go</code> 关键字创建了两个并发的 goroutines。<code>sum</code> 函数接收一个前缀字符串、一个整数 n 和一个通道 ch。该函数计算斐波那契数列的前 n 项之和，并将结果发送到通道 ch。</p>
<p>在 main 函数中，我们创建了一个有缓冲的通道 ch 和一个 WaitGroup wg。WaitGroup 用于等待所有的 goroutines 完成。我们分别为 “Fibonacci Sum” 和 “Fibonacci Square Sum” 启动两个 goroutines。</p>
<p>当两个 goroutines 完成后，我们关闭通道 ch，然后从通道中读取计算结果，累加并输出最终的总和。</p>
<h2 id="CSP（Communicating-Sequential-Processes）"><a href="#CSP（Communicating-Sequential-Processes）" class="headerlink" title="CSP（Communicating Sequential Processes）"></a>CSP（Communicating Sequential Processes）</h2><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><h6 id="一种表达并发的范式"><a href="#一种表达并发的范式" class="headerlink" title="一种表达并发的范式"></a>一种表达并发的范式</h6><ul>
<li>基于消息传递</li>
<li>最初由 Tony Hoare 在 1978 年的一篇论文中描述（Actor 模型最早在 1973 年被描述）</li>
</ul>
<h6 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h6><ul>
<li>顺序<strong>进程</strong></li>
<li>通过<strong>通道</strong>进行同步通信</li>
<li>使用<strong>交替</strong>方式复用通道</li>
</ul>
<h4 id="Two-Models-of-Concurrency"><a href="#Two-Models-of-Concurrency" class="headerlink" title="Two Models of Concurrency"></a>Two Models of Concurrency</h4><h6 id="Shared-Memory"><a href="#Shared-Memory" class="headerlink" title="Shared Memory"></a>Shared Memory</h6><ul>
<li>Threads</li>
<li>Locks</li>
<li>Mutexes</li>
</ul>
<h6 id="Message-Passing-CSP-and-Actor-Model"><a href="#Message-Passing-CSP-and-Actor-Model" class="headerlink" title="Message Passing (CSP and Actor Model)"></a>Message Passing (CSP and Actor Model)</h6><ul>
<li>Processes</li>
<li>Messages</li>
<li>No shared data</li>
</ul>
<h4 id="Shared-Memory-Problem-1"><a href="#Shared-Memory-Problem-1" class="headerlink" title="Shared Memory - Problem 1"></a>Shared Memory - Problem 1</h4><img src="/images/image-20230322183223952.png" alt="image-20230322183223952" style="zoom: 50%;" />

<p>程序在关键区域崩溃会导致内存损坏</p>
<ul>
<li>难以推理</li>
<li>难以从故障中恢复</li>
</ul>
<h4 id="Shared-Memory-Problem-2"><a href="#Shared-Memory-Problem-2" class="headerlink" title="Shared Memory - Problem 2"></a>Shared Memory - Problem 2</h4><img src="/images/image-20230322183323601.png" alt="image-20230322183323601" style="zoom:50%;" />

<p>共享内存物理上位于哪里？</p>
<ul>
<li>从故障中恢复更加困难</li>
</ul>
<h4 id="Multi-x2F-Many-core-is-a-Reality"><a href="#Multi-x2F-Many-core-is-a-Reality" class="headerlink" title="Multi&#x2F;Many-core is a Reality"></a>Multi&#x2F;Many-core is a Reality</h4><img src="/images/image-20230322183713757.png" alt="image-20230322183713757" style="zoom:50%;" />

<ul>
<li>Commercially available</li>
<li>72 identical cores @ 1.0 to 1.2GHz</li>
<li>256 KB L2 per core</li>
</ul>
<h4 id="A-concurrency-oriented-language"><a href="#A-concurrency-oriented-language" class="headerlink" title="A concurrency oriented language"></a>A concurrency oriented language</h4><blockquote>
<p>面向对象语言是指具有良好的对象支持的语言。面向并发语言则是指<strong>具有良好的并发支持</strong>的语言。</p>
</blockquote>
<p>by <a href="http://www.guug.de/veranstaltungen/ffg2003/papers/ffg2003-armstrong.pdf">Concurrency Oriented Programming in Erlang</a></p>
<h4 id="Channel-vs-Mailbox"><a href="#Channel-vs-Mailbox" class="headerlink" title="Channel vs Mailbox"></a>Channel vs Mailbox</h4><img src="/images/image-20230322184046081.png" alt="image-20230322184046081" style="zoom: 67%;" />

<ul>
<li>CSP<ul>
<li>通过channels进行通信</li>
<li>进程是“匿名”的</li>
</ul>
</li>
</ul>
<img src="/images/image-20230322184140789.png" alt="image-20230322184140789" style="zoom:50%;" />

<ul>
<li>Actor Model<ul>
<li>点对点通信</li>
<li>没有匿名性</li>
</ul>
</li>
</ul>
<h4 id="CSP-–-通信语义"><a href="#CSP-–-通信语义" class="headerlink" title="CSP – 通信语义"></a>CSP – 通信语义</h4><img src="/images/image-20230322184249599.png" alt="image-20230322184249599" style="zoom:50%;" />

<h4 id="Actor-Model-–-通信语义"><a href="#Actor-Model-–-通信语义" class="headerlink" title="Actor Model – 通信语义"></a>Actor Model – 通信语义</h4><img src="/images/image-20230322184354451.png" alt="image-20230322184354451" style="zoom:50%;" />

<h4 id="为什么选择-CSP模型作为-Go-并发模型的基础"><a href="#为什么选择-CSP模型作为-Go-并发模型的基础" class="headerlink" title="为什么选择 CSP模型作为 Go 并发模型的基础"></a>为什么选择 CSP模型作为 Go 并发模型的基础</h4><p>CSP 模型中的基本思想是将复杂系统拆分为一系列独立的顺序执行的进程。这些进程通过消息传递进行通信，而不是通过共享内存。这意味着进程之间不存在竞争条件，因此在编写并发程序时，开发人员可以将精力集中在处理业务逻辑上，而不是解决并发相关的复杂问题。</p>
<p>CSP 模型有以下特点：</p>
<ol>
<li><strong>进程</strong>：CSP 将复杂系统分解为一系列独立的顺序执行的进程。</li>
<li><strong>通信</strong>：进程之间通过消息传递进行通信，而不是共享内存。这简化了并发控制，避免了竞争条件的产生。</li>
<li><strong>同步</strong>：CSP 模型中的通信是同步的，即发送进程在消息被接收之前会阻塞。这使得<strong>协调并发操作</strong>变得更加容易。</li>
</ol>
<p>Go 语言选择了 CSP 模型作为并发模型的基础，原因如下：</p>
<ol>
<li><strong>简化并发编程</strong>：CSP 模型通过消除共享内存以及与之相关的竞争条件，使得编写并发程序更加简单。</li>
<li><strong>模型易于理解和使用</strong>：CSP 模型的基本概念容易理解，程序员可以很快地学会如何编写高效的并发代码。</li>
<li><strong>扩展性</strong>：CSP 模型易于扩展，可以轻松地<strong>将单个进程替换为一组并发执行的进程</strong>，以提高程序的性能和响应能力。</li>
<li><strong>灵活性</strong>：CSP 模型可以与其他并发模型（如事件驱动和回调）结合使用，以满足不同的应用需求。</li>
</ol>
<p>Go 语言通过 goroutines（轻量级线程）和 channels（通道）提供了 CSP 模型的实现。goroutines 使得创建并发执行的任务变得简单且高效，而 channels 则为 goroutines 之间提供了安全的通信机制。Go 的并发原语让程序员能够更加专注于解决实际问题，而不需要花费大量时间处理并发相关的复杂性。</p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>Learning</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 新手可能会踩的 50 个坑</title>
    <url>/2023/03/22/Golang-%E6%96%B0%E6%89%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%B8%A9%E7%9A%84-50-%E4%B8%AA%E5%9D%91/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 是一门简单有趣的编程语言，与其他语言一样，在使用时不免会遇到很多坑，不过它们大多不是 Go 本身的设计缺陷。如果你刚从其他语言转到 Go，那这篇文章里的坑多半会踩到。</p>
<p>如果花时间学习官方 doc、wiki、<a href="https://link.segmentfault.com/?enc=zahJmd2JKI3xjUX097odzg==.eCFPArq81bucNaDads0EWBY3wKnpv/DC1MnzWtcfoi1N8IcPAR6bAUU5DhP+k+dhKh0l22xohsHC9Lo0qnhcug==">讨论邮件列表</a>、 <a href="https://link.segmentfault.com/?enc=8CefyIlbAWT2Nu6P0jcg2g==.PwwL9x3MWV4f2MGg3DmQZfg7kTu2VSvrsf2iUCsRiII=">Rob Pike</a> 的大量文章以及 Go 的源码，会发现这篇文章中的坑是很常见的，新手跳过这些坑，能减少大量调试代码的时间。</p>
<h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h4 id="左大括号-不能单独放一行"><a href="#左大括号-不能单独放一行" class="headerlink" title="左大括号 { 不能单独放一行"></a>左大括号 <code>&#123;</code> 不能单独放一行</h4><p>在其他大多数语言中，<code>&#123;</code> 的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 <code>;</code> 来分隔多条语句，比如会在 <code>)</code> 后加分号：</p>
<p>因此正确示例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<h4 id="未使用的变量"><a href="#未使用的变量" class="headerlink" title="未使用的变量"></a>未使用的变量</h4><p>如果在函数体代码中有<strong>未使用</strong>的变量，则无法通过编译，不过<strong>全局变量声明但不使用是可以的</strong>。</p>
<h4 id="未使用的-import"><a href="#未使用的-import" class="headerlink" title="未使用的 import"></a>未使用的 import</h4><p>如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。</p>
<p>可以使用 <code>_</code> 下划线符号作为别名来忽略导入的包，从而避免编译错误，<strong>这只会执行 package 的 <code>init()</code></strong></p>
<h4 id="简短声明的变量只能在函数内部使用"><a href="#简短声明的变量只能在函数内部使用" class="headerlink" title="简短声明的变量只能在函数内部使用"></a>简短声明的变量只能在函数内部使用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">myvar := <span class="number">1</span>    <span class="comment">// syntax error: non-declaration statement outside function body</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">var</span> myvar = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用简短声明来重复声明变量"><a href="#使用简短声明来重复声明变量" class="headerlink" title="使用简短声明来重复声明变量"></a>使用简短声明来重复声明变量</h4><p>不能用简短声明方式来单独为一个变量<strong>重复声明</strong>， <code>:=</code> 左侧<strong>至少有一个新变量</strong>，才允许多变量的重复声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one := <span class="number">1</span> <span class="comment">// error: no new variables on left side of :=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one, two := <span class="number">1</span>, <span class="number">2</span>    <span class="comment">// two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err</span></span><br><span class="line">    one, two = two, one    <span class="comment">// 交换两个变量值的简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不能使用简短声明来设置字段的值"><a href="#不能使用简短声明来设置字段的值" class="headerlink" title="不能使用简短声明来设置字段的值"></a>不能使用简短声明来设置字段的值</h4><p>struct 的变量字段不能使用 <code>:=</code> 来赋值以使用预定义的变量来避免解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">    result <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    data.result, err := work()    <span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span>    <span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">    data.result, err = work()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不小心覆盖了变量"><a href="#不小心覆盖了变量" class="headerlink" title="不小心覆盖了变量"></a>不小心覆盖了变量</h4><p>对从动态语言转过来的开发者来说，简短声明很好用，这可能<strong>会让人误会 <code>:=</code> 是一个赋值操作符</strong>。</p>
<p>如果你在新的代码块中像下边这样误用了 <code>:=</code>，编译不会报错，但是变量不会按你的预期工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 1</span></span><br><span class="line">        x := <span class="number">2</span></span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 2    // 新的 x 变量的作用域只在代码块内部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="显式类型的变量无法使用-nil-来初始化"><a href="#显式类型的变量无法使用-nil-来初始化" class="headerlink" title="显式类型的变量无法使用 nil 来初始化"></a>显式类型的变量无法使用 nil 来初始化</h4><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span>    <span class="comment">// error: use of untyped nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h4 id="直接使用值为-nil-的-slice、map"><a href="#直接使用值为-nil-的-slice、map" class="headerlink" title="直接使用值为 nil 的 slice、map"></a>直接使用值为 nil 的 slice、map</h4><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>        <span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int)// map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="map-容量"><a href="#map-容量" class="headerlink" title="map 容量"></a>map 容量</h4><p>在创建 map 类型的变量时可以指定容量，但<strong>不能像 slice 一样使用 <code>cap()</code> 来检测分配空间的大小</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="built_in">println</span>(<span class="built_in">cap</span>(m))     <span class="comment">// error: invalid argument m1 (type map[string]int) for cap  </span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h4 id="string-类型的变量值不能为-nil"><a href="#string-类型的变量值不能为-nil" class="headerlink" title="string 类型的变量值不能为 nil"></a>string 类型的变量值不能为 nil</h4><p>对那些喜欢用 <code>nil</code> 初始化字符串的人来说，这就是坑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">string</span> = <span class="literal">nil</span>    <span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;    <span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">string</span>    <span class="comment">// 字符串类型的零值是空串 &quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Array-类型的值作为函数参数"><a href="#Array-类型的值作为函数参数" class="headerlink" title="Array 类型的值作为函数参数"></a>Array 类型的值作为函数参数</h4><p>在 C&#x2F;C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。</p>
<p>在 Go 中，数组是值。作为参数传进函数时，传递的是数组的<strong>原始值拷贝，此时在函数内部是无法更新该数组的</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组使用值拷贝传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)            <span class="comment">// [1 2 3]    // 并不是你以为的 [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想修改参数数组：</p>
<ul>
<li>直接传递指向这个数组的指针类型：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传址会修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        (*arr)[<span class="number">0</span>] = <span class="number">7</span>    </span><br><span class="line">        fmt.Println(arr)    <span class="comment">// &amp;[7 2 3]</span></span><br><span class="line">    &#125;(&amp;x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会修改 slice 的底层 array，从而修改 slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="range-遍历-slice-和-array-时混淆了返回值"><a href="#range-遍历-slice-和-array-时混淆了返回值" class="headerlink" title="range 遍历 slice 和 array 时混淆了返回值"></a>range 遍历 slice 和 array 时混淆了返回值</h4><p>与其他编程语言中的 <code>for-in</code> 、<code>foreach</code> 遍历语句不同，Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">        fmt.Println(v)    <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;    <span class="comment">// 使用 _ 丢弃索引</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="slice-和-array-其实是一维数据"><a href="#slice-和-array-其实是一维数据" class="headerlink" title="slice 和 array 其实是一维数据"></a>slice 和 array 其实是一维数据</h4><p><strong>看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。</strong></p>
<p>对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。</p>
<p>可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。</p>
<ol>
<li>使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。</li>
<li><strong>使用“独立”的切片</strong>分两步：</li>
</ol>
<ul>
<li><p>创建外部 slice</p>
<ul>
<li><p>对每个内部 slice 进行内存分配</p>
<p>注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="type">int</span>, x)</span><br><span class="line">    <span class="keyword">for</span> i  := <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = <span class="built_in">make</span>([]<span class="type">int</span>, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>使用“共享底层数组”的切片:</p>
<ul>
<li><p>创建一个存放原始数据的容器 slice</p>
</li>
<li><p>创建其他的 slice</p>
</li>
<li><p>切割原始 slice 来初始化其他的 slice</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h, w := <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">int</span>, h*w)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> raw &#123;</span><br><span class="line">        raw[i] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化原始 slice</span></span><br><span class="line">    fmt.Println(raw, &amp;raw[<span class="number">4</span>])    <span class="comment">// [0 1 2 3 4 5 6 7] 0xc420012120 </span></span><br><span class="line">    </span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="type">int</span>, h)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> table &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等间距切割原始 slice，创建动态多维数组 table</span></span><br><span class="line">        <span class="comment">// 0: raw[0*4: 0*4 + 4]</span></span><br><span class="line">        <span class="comment">// 1: raw[1*4: 1*4 + 4]</span></span><br><span class="line">        table[i] = raw[i*w : i*w + w]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(table, &amp;table[<span class="number">1</span>][<span class="number">0</span>])    <span class="comment">// [[0 1 2 3] [4 5 6 7]] 0xc420012120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问-map-中不存在的-key"><a href="#访问-map-中不存在的-key" class="headerlink" title="访问 map 中不存在的 key"></a>访问 map 中不存在的 key</h4><p>和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil.</p>
<p>Go 则会返回元素对应数据类型的零值，比如 <code>nil</code>、<code>&#39;&#39;</code> 、<code>false</code> 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。</p>
<p>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的 key 检测方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> v := x[<span class="string">&quot;two&quot;</span>]; v == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)    <span class="comment">// 键 two 存不存在都会返回的空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> _, ok := x[<span class="string">&quot;two&quot;</span>]; !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="string-类型的值是常量，不可更改"><a href="#string-类型的值是常量，不可更改" class="headerlink" title="string 类型的值是常量，不可更改"></a>string 类型的值是常量，不可更改</h4><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。</p>
<p>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改字符串的错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    x[<span class="number">0</span>] = <span class="string">&quot;T&quot;</span>        <span class="comment">// error: cannot assign to x[0]</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    xBytes := []<span class="type">byte</span>(x)</span><br><span class="line">    xBytes[<span class="number">0</span>] = <span class="string">&#x27;T&#x27;</span>    <span class="comment">// 注意此时的 T 是 rune 类型</span></span><br><span class="line">    x = <span class="type">string</span>(xBytes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。</p>
<p>更新字串的正确姿势：<strong>将 string 转为 rune slice</strong>（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    xRunes := []<span class="type">rune</span>(x)</span><br><span class="line">    xRunes[<span class="number">0</span>] = <span class="string">&#x27;我&#x27;</span></span><br><span class="line">    x = <span class="type">string</span>(xRunes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// 我ext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="string-与索引操作符"><a href="#string-与索引操作符" class="headerlink" title="string 与索引操作符"></a>string 与索引操作符</h4><p>对字符串用索引访问返回的不是字符，而是一个 byte 值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;ascii&quot;</span></span><br><span class="line">    fmt.Println(x[<span class="number">0</span>])        <span class="comment">// 97</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, x[<span class="number">0</span>])<span class="comment">// uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用 <code>for range</code> 迭代访问字符串中的字符（unicode code point &#x2F; rune），标准库中有 <code>&quot;unicode/utf8&quot;</code> 包来做 UTF8 的相关解码编码。另外 <a href="https://link.segmentfault.com/?enc=MfxOkrLm6Kyv/gokphKK3A==.ZHmogRa7WvN1UT1iZ/Bq+DpNUj9OaSftLy38LP96lC7b8Ggnq9h1k3ob2KLLMwRf">utf8string</a> 也有像 <code>func (s *String) At(i int) rune</code> 等很方便的库函数。</p>
<h4 id="字符串并不都是-UTF8-文本"><a href="#字符串并不都是-UTF8-文本" class="headerlink" title="字符串并不都是 UTF8 文本"></a>字符串并不都是 UTF8 文本</h4><p>string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，<strong>字符串可以通过转义来包含其他数据</strong>。</p>
<p>判断字符串是否是 UTF8 文本，可使用 “unicode&#x2F;utf8” 包中的 <code>ValidString()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str1 := <span class="string">&quot;ABC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str1))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    str2 := <span class="string">&quot;A\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str2))    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    str3 := <span class="string">&quot;A\\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str3))    <span class="comment">// true    // 把转义字符转义成字面值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h4><p>在 Python 中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">u&#x27;♥&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>然而在 Go 中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    char := &quot;♥&quot;</span><br><span class="line">    fmt.Println(len(char))    // 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 的内建函数 <code>len()</code> <strong>返回的是字符串的 byte 数量</strong>，<strong>而不是像 Python 中那样是计算 Unicode 字符数</strong>。</p>
<p>如果要得到字符串的字符数，可使用 <code>&quot;unicode/utf8&quot;</code> 包中的 <code>RuneCountInString(str string) (n int)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在多行-array、slice、map-语句中缺少-号"><a href="#在多行-array、slice、map-语句中缺少-号" class="headerlink" title="在多行 array、slice、map 语句中缺少 , 号"></a>在多行 array、slice、map 语句中缺少 <code>,</code> 号</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">int</span> &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>    <span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;    </span><br><span class="line">    z := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明语句中 <code>&#125;</code> <strong>折叠到单行后</strong>，尾部的 <code>,</code> 不是必需的。</p>
<h4 id="log-Fatal-和-log-Panic-不只是-log"><a href="#log-Fatal-和-log-Panic-不只是-log" class="headerlink" title="log.Fatal 和 log.Panic 不只是 log"></a><code>log.Fatal</code> 和 <code>log.Panic</code> 不只是 log</h4><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 <code>Fatal*()</code>、<code>Panic*()</code> 时能做更多日志外的事，如中断程序的执行等：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;Fatal level log: log entry&quot;</span>)        <span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">    log.Println(<span class="string">&quot;Nomal level log: log entry&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对内建数据结构的操作并不是同步的"><a href="#对内建数据结构的操作并不是同步的" class="headerlink" title="对内建数据结构的操作并不是同步的"></a>对内建数据结构的操作并不是同步的</h4><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，<strong>用户需自己保证变量等数据以原子操作更新</strong>。</p>
<p><code>goroutine</code> 和 <code>channel</code> 是进行原子操作的好方法，或使用 <code>&quot;sync&quot;</code> 包中的锁。</p>
<h4 id="range-迭代-string-得到的值"><a href="#range-迭代-string-得到的值" class="headerlink" title="range 迭代 string 得到的值"></a>range 迭代 string 得到的值</h4><p>range 得到的索引是字符值（Unicode point &#x2F; rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。</p>
<p>注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用<a href="https://link.segmentfault.com/?enc=U278Gu0H927WNOi9knZ2/Q==.Nr0TyIrCkHKZ6d8qTUGDFeES4DBRw3VoDRtbfG7kMI+hjg4k2hJ0N6JMdmfnk8oR+MFUYxeVyhhAdBqClhhZUg==">norm</a> 包。</p>
<p><strong>for range 迭代会尝试将 string 翻译为 UTF8 文本</strong>，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="string">&quot;A\xfe\x02\xff\x04&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4    // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">byte</span>(data) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfe 0x2 0xff 0x4    // 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="range-迭代-map"><a href="#range-迭代-map" class="headerlink" title="range 迭代 map"></a>range 迭代 map</h4><p>如果你希望<strong>以特定的顺序</strong>（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。</p>
<p><strong>Go 的运行时是有意打乱迭代顺序的</strong>，<strong>所以你得到的迭代结果可能不一致</strong>。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>, <span class="string">&quot;four&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch-中的-fallthrough-语句"><a href="#switch-中的-fallthrough-语句" class="headerlink" title="switch 中的 fallthrough 语句"></a>switch 中的 fallthrough 语句</h4><p><code>switch</code> 语句中的 <code>case</code> 代码块会<strong>默认带上 break</strong>，但可以使用 <code>fallthrough</code> 来强制执行下一个 case 代码块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:    <span class="comment">// 空格符会直接 break，返回 false // 和其他语言不一样</span></span><br><span class="line">        <span class="comment">// fallthrough    // 返回 true</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过你可以在 case 代码块末尾使用 <code>fallthrough</code>，强制执行下一个 case 代码块。</p>
<p>也可以改写 case 为<strong>多条件判断</strong>：</p>
<h4 id="自增和自减运算"><a href="#自增和自减运算" class="headerlink" title="自增和自减运算"></a>自增和自减运算</h4><p>很多编程语言都自带前置后置的 <code>++</code>、<code>--</code> 运算。但 Go 特立独行，<strong>去掉了前置操作</strong>，同时 <code>++</code>、<code>--</code> 只作为运算符而非表达式（表达式中不能用）。</p>
<h4 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h4><p>很多编程语言使用 <code>~</code> 作为一元按位取反（NOT）操作符，Go 重用 <code>^</code> XOR 操作符来按位取反：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的取反操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(~<span class="number">2</span>)        <span class="comment">// bitwise complement operator is ^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d <span class="type">uint8</span> = <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, d)        <span class="comment">// 00000010</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, ^d)    <span class="comment">// 11111101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时 <code>^</code> 也是按位异或（XOR）操作符。</p>
<p>一个操作符能重用两次，是因为一元的 NOT 操作 <code>NOT 0x02</code>，与二元的 XOR 操作 <code>0x22 XOR 0xff</code> 是一致的。</p>
<p>Go 也有特殊的操作符 AND NOT <code>&amp;^</code> 操作符，不同位才取1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">uint8</span> = <span class="number">0x82</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">0x02</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [A]\n&quot;</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [B]\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b (NOT B)\n&quot;</span>, ^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [B XOR 0xff]\n&quot;</span>, b, <span class="number">0xff</span>, b^<span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [A XOR B]\n&quot;</span>, a, b, a^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp; %08b = %08b [A AND B]\n&quot;</span>, a, b, a&amp;b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp;^%08b = %08b [A &#x27;AND NOT&#x27; B]\n&quot;</span>, a, b, a&amp;^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&quot;</span>, a, b, a&amp;(^b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h4><p>除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。</p>
<table>
<thead>
<tr>
<th align="center">Precedence</th>
<th align="center">Operator</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5</td>
<td align="center">*  &#x2F;  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">+  -  |  ^</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">&#x3D;&#x3D;  !&#x3D;  &lt;  &lt;&#x3D;  &gt;  &gt;&#x3D;</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">&amp;&amp;</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">||</td>
</tr>
</tbody></table>
<h4 id="不导出的-struct-字段无法被-encode"><a href="#不导出的-struct-字段无法被-encode" class="headerlink" title="不导出的 struct 字段无法被 encode"></a>不导出的 struct 字段无法被 encode</h4><p><strong>以小写字母开头的字段成员是无法被外部直接访问的</strong>，所以 <code>struct</code> 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyData <span class="keyword">struct</span> &#123;  </span><br><span class="line">    One <span class="type">int</span></span><br><span class="line">    two <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := MyData&#123;<span class="number">1</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, in)    <span class="comment">// main.MyData&#123;One:1, two:&quot;two&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">    encoded, _ := json.Marshal(in)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(encoded))    <span class="comment">// &#123;&quot;One&quot;:1&#125;    // 私有字段 two 被忽略了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out MyData</span><br><span class="line">    json.Unmarshal(encoded, &amp;out)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, out)     <span class="comment">// main.MyData&#123;One:1, two:&quot;&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="程序退出时还有-goroutine-在执行"><a href="#程序退出时还有-goroutine-在执行" class="headerlink" title="程序退出时还有 goroutine 在执行"></a>程序退出时还有 goroutine 在执行</h4><p><strong>程序默认不等所有 goroutine 都执行完才退出</strong>，这点需要特别注意：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主程序会直接退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> doIt(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)        <span class="comment">// 模拟 goroutine 正在执行 </span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下，<code>main()</code> 主程序不等两个 goroutine 执行完就直接退出了：</p>
<img src="/images/image-20230322205202650.png" alt="image-20230322205202650" style="zoom: 67%;" />

<p>常用解决办法：使用 <code>&quot;WaitGroup&quot;</code> 变量，它会让主程序等待所有 goroutine 执行完毕再退出。</p>
<p>如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 <code>kill</code> 消息来关闭它们。或<strong>直接关闭一个它们都等待接收数据的 channel</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)    <span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;    <span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] m =&gt; %v\n&quot;</span>, workerID, m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回"><a href="#向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回" class="headerlink" title="向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回"></a>向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回</h4><p>只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，<strong>receiver 的 goroutine 可能没有足够的时间处理下一个数据</strong>。如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;processed:&quot;</span>, m)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	ch &lt;- <span class="string">&quot;cmd.1&quot;</span></span><br><span class="line">	ch &lt;- <span class="string">&quot;cmd.2&quot;</span> <span class="comment">//won&#x27;t be processed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/image-20230322210307223.png" alt="image-20230322210307223" style="zoom: 67%;" />

<p>goroutine 还没处理主程序就退出了。</p>
<h4 id="向已关闭的-channel-发送数据会造成-panic"><a href="#向已关闭的-channel-发送数据会造成-panic" class="headerlink" title="向已关闭的 channel 发送数据会造成 panic"></a>向已关闭的 channel 发送数据会造成 panic</h4><p>从已关闭的 channel 接收数据是安全的：</p>
<p>接收状态值 <code>ok</code> 是 <code>false</code> 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 <code>false</code></p>
<p>向已关闭的 channel 中发送数据会造成 panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- idx</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-ch)        <span class="comment">// 输出第一个发送的值</span></span><br><span class="line">    <span class="built_in">close</span>(ch)            <span class="comment">// 不能关闭，还有其他的 sender</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)    <span class="comment">// 模拟做其他的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>panic: send on closed channel</code></p>
<p>针对上边有 bug 的这个例子，可使用一个废弃 channel <code>done</code> 来告诉剩余的 goroutine 无需再向 ch 发送数据。此时 <code>&lt;- done</code> 的结果是 <code>&#123;&#125;</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Send result&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Exiting&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用了值为-nil-的-channel"><a href="#使用了值为-nil-的-channel" class="headerlink" title="使用了值为 nil 的 channel"></a>使用了值为 <code>nil </code>的 channel</h4><p>在一个值为 nil 的 channel 上发送和接收数据将永久阻塞：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 未初始化，值为 nil</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtime 死锁错误：</p>
<blockquote>
<p>fatal error: all goroutines are asleep - deadlock!<br>goroutine 1 [chan receive (nil chan)]</p>
</blockquote>
<p>利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> in &lt;-<span class="keyword">chan</span> <span class="type">int</span> = inCh</span><br><span class="line">		<span class="keyword">var</span> out <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line">		<span class="keyword">var</span> val <span class="type">int</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> out &lt;- val:</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">&quot;--------&quot;</span>)</span><br><span class="line">				out = <span class="literal">nil</span>  <span class="comment">// 关</span></span><br><span class="line">				in = inCh  <span class="comment">// 开</span></span><br><span class="line">			<span class="keyword">case</span> val = &lt;-in:</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">&quot;++++++++++&quot;</span>)</span><br><span class="line">				out = outCh  <span class="comment">// 开</span></span><br><span class="line">				in = <span class="literal">nil</span>  <span class="comment">// 关</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> r := <span class="keyword">range</span> outCh &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Result: &quot;</span>, r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">0</span>)</span><br><span class="line">	inCh &lt;- <span class="number">1</span></span><br><span class="line">	inCh &lt;- <span class="number">2</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20230323140309870.png" alt="image-20230323140309870"></p>
<h4 id="若函数-receiver-传参是传值方式，则无法修改参数的原有值"><a href="#若函数-receiver-传参是传值方式，则无法修改参数的原有值" class="headerlink" title="若函数 receiver 传参是传值方式，则无法修改参数的原有值"></a>若函数 receiver 传参是传值方式，则无法修改参数的原有值</h4><p>方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p>
<p>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	num   <span class="type">int</span></span><br><span class="line">	key   *<span class="type">string</span></span><br><span class="line">	items <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span></span> pointerFunc() &#123;</span><br><span class="line">	this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span></span> valueFunc() &#123;</span><br><span class="line">	this.num = <span class="number">8</span></span><br><span class="line">	*this.key = <span class="string">&quot;valueFunc.key&quot;</span></span><br><span class="line">	this.items[<span class="string">&quot;valueFunc&quot;</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	key := <span class="string">&quot;key1&quot;</span></span><br><span class="line"></span><br><span class="line">	d := data&#123;<span class="number">1</span>, &amp;key, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">	d.pointerFunc() <span class="comment">// 修改 num 的值为 7</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">	d.valueFunc() <span class="comment">// 修改 key 和 items 的值</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/image-20230323140725966.png" alt="image-20230323140725966" style="zoom: 67%;" />

<h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><h4 id="关闭-HTTP-的响应体"><a href="#关闭-HTTP-的响应体" class="headerlink" title="关闭 HTTP 的响应体"></a>关闭 HTTP 的响应体</h4><p>当使用标准的 <code>net/http</code> 库发送 HTTP 请求时，会得到一个 HTTP 响应变量。如果不读取响应体，仍然需要关闭它。请注意，即使是空响应，也必须关闭它。这对于新手 Go 开发人员来说非常容易忘记。</p>
<p>一些新手 Go 开发人员尝试关闭响应体，但是在错误的位置关闭了它。</p>
<p>简而言之，当使用 Go 的 <code>net/http</code> 包发送 HTTP 请求时，响应对象包含一个 <code>Body</code> 字段，它是一个实现了 <code>io.Reader</code> 和 <code>io.Closer</code> 接口的 <code>ReadCloser</code> 接口，用于表示 HTTP 响应的主体。如果你不读取响应主体，你<strong>仍然需要关闭它，以释放与它相关联的任何资源</strong>。即使响应是空的，也必须关闭响应体。对于新手 Go 开发人员来说，很容易忘记关闭响应体，或者在错误的位置关闭它。为了避免这个问题，可以使用 <code>defer</code> 语句确保响应体始终被关闭，即使出现错误或 panic。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求失败造成 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()<span class="comment">//not ok</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以处理成功的 HTTP 请求，但是如果 HTTP 请求失败，<code>resp</code> 变量可能为空（<code>nil</code>），这将导致运行时出现 panic。</p>
<p>最常见的关闭响应体的方法是在 HTTP 响应错误检查之后使用 <code>defer</code> 调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close() <span class="comment">//ok, most of the time :-)</span></span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数情况下，当 HTTP 请求失败时，<code>resp</code> 变量将为空（<code>nil</code>），而 <code>err</code> 变量将为非空。但是，当重定向失败时，这两个变量都将为非空。这意味着你仍然可能会出现资源泄漏。</p>
<p>你可以通过在 HTTP 响应错误处理块中添加一个调用来关闭非空的响应体来解决此泄漏问题。另一种选择是使用一个 <code>defer</code> 调用来为所有失败和成功的请求关闭响应体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关闭-HTTP-连接"><a href="#关闭-HTTP-连接" class="headerlink" title="关闭 HTTP 连接"></a><strong>关闭 HTTP 连接</strong></h4><p>有些 HTTP 服务器会在一段时间内保持网络连接开启（基于 HTTP 1.1 规范和服务器的 “keep-alive” 配置）。默认情况下，标准的 <code>net/http</code> 库<strong>只在目标 HTTP 服务器请求关闭时才关闭网络连接</strong>。这意味着在某些情况下，你的应用程序可能会耗尽套接字&#x2F;文件描述符。</p>
<p>你<strong>可以通过将请求变量中的 Close 字段设置为 true 来要求 http 库在请求完成后关闭连接</strong>。</p>
<p>另一种选择是添加一个 Connection 请求头，并将其设置为 close。目标 HTTP 服务器应该也会响应一个 Connection: close 头。当 http 库看到这个响应头时，它也会关闭连接。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http://golang.org&quot;</span>,<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.Close = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//or do this:</span></span><br><span class="line">    <span class="comment">//req.Header.Add(&quot;Connection&quot;, &quot;close&quot;)</span></span><br><span class="line"></span><br><span class="line">    resp, err := http.DefaultClient.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="type">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以全局禁用 HTTP 连接重用。你需要创建一个自定义的 HTTP 传输配置来实现它。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    tr := &amp;http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">    client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line"></span><br><span class="line">    resp, err := client.Get(<span class="string">&quot;http://golang.org&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(resp.StatusCode)</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="type">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你<strong>向同一个 HTTP 服务器发送大量请求，保持网络连接开启是可以的</strong>。但是，如果你的应用程序在短时间内向许多不同的 HTTP 服务器发送一两个请求，那么在应用程序接收到响应后立即关闭网络连接是一个不错的选择。增加打开文件限制也可能是一个不错的选择。但是，正确的解决方案取决于你的应用程序。</p>
<h4 id="JSON-Encoder-在结尾添加一个换行符"><a href="#JSON-Encoder-在结尾添加一个换行符" class="headerlink" title="JSON Encoder 在结尾添加一个换行符"></a>JSON Encoder 在结尾添加一个换行符</h4><p>你正在为你的 JSON 编码函数编写测试时，你发现测试失败了，因为你没有得到预期的值。发生了什么？如果你正在使用 JSON Encoder 对象，则在编码的 JSON 对象的末尾会得到一个额外的换行符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;key&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">  json.NewEncoder(&amp;b).Encode(data)</span><br><span class="line"></span><br><span class="line">  raw,_ := json.Marshal(data)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> b.String() == <span class="type">string</span>(raw) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;same encoded data&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;&#x27;%s&#x27; != &#x27;%s&#x27;\n&quot;</span>,raw,b.String())</span><br><span class="line">    <span class="comment">//prints:</span></span><br><span class="line">    <span class="comment">//&#x27;&#123;&quot;key&quot;:1&#125;&#x27; != &#x27;&#123;&quot;key&quot;:1&#125;\n&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON Encoder 对象是为流式处理而设计的。使用 JSON 流通常意味着换行分隔的 JSON 对象，这就是为什么 Encode 方法会添加一个换行符的原因。这是一种已经记录在文档中的行为，但通常被忽视或遗忘。</p>
<h4 id="JSON-Package-在-Keys-和字符串-Values-中转义特殊的-HTML-字符。"><a href="#JSON-Package-在-Keys-和字符串-Values-中转义特殊的-HTML-字符。" class="headerlink" title="JSON Package 在 Keys 和字符串 **Values **中转义特殊的 HTML 字符。"></a>JSON <strong>Package</strong> 在 <strong>Keys</strong> 和字符串 **Values **中转义特殊的 HTML 字符。</h4><p>这是一种已经记录在文档中的行为，但你必须仔细阅读所有的 JSON 包文档才能了解它。<strong>SetEscapeHTML 方法的描述谈到了默认的编码行为，针对小于号、大于号和和符号。</strong></p>
<p>这是 Go 团队做出的一个非常不幸的设计决策，原因有很多。首先，你无法禁用这个行为，对于 json.Marshal 调用来说，这是不好的。其次，这是一个糟糕的安全功能，因为它假定在所有 web 应用程序中进行 HTML 编码就足以保护免受 XSS 漏洞的攻击。数据可以用于许多不同的上下文，每个上下文都需要自己的编码方法。最后，它是不好的，因为它假定 JSON 的主要用例是网页，这默认破坏了配置库和 REST&#x2F;HTTP API。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := <span class="string">&quot;x &lt; y&quot;</span></span><br><span class="line"></span><br><span class="line">	raw, _ := json.Marshal(data)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(raw))</span><br><span class="line">	<span class="comment">//prints: &quot;x \u003c y&quot; &lt;- probably not what you expected</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b1 bytes.Buffer</span><br><span class="line">	json.NewEncoder(&amp;b1).Encode(data)</span><br><span class="line">	fmt.Println(b1.String())</span><br><span class="line">	<span class="comment">//prints: &quot;x \u003c y&quot; &lt;- probably not what you expected</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b2 bytes.Buffer</span><br><span class="line">	enc := json.NewEncoder(&amp;b2)</span><br><span class="line">	enc.SetEscapeHTML(<span class="literal">false</span>)</span><br><span class="line">	enc.Encode(data)</span><br><span class="line">	fmt.Println(b2.String())</span><br><span class="line">	<span class="comment">//prints: &quot;x &lt; y&quot; &lt;- looks better</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Go 团队，我的建议是让这个行为成为一个可选项（opt-in）。</p>
<h4 id="将-JSON-数字解组为接口值"><a href="#将-JSON-数字解组为接口值" class="headerlink" title="将 JSON 数字解组为接口值"></a>将 JSON 数字解组为接口值</h4><p>默认情况下，当你将 JSON 数据解码&#x2F;解组为接口时，Go 会将其中的数字值视为 <strong>float64</strong> 数字。这意味着以下代码会因为 panic 而失败：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> status = result[<span class="string">&quot;status&quot;</span>].(<span class="type">int</span>) <span class="comment">//error</span></span><br><span class="line">    <span class="comment">// var status = uint64(result[&quot;status&quot;].(float64)) //ok</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;status value:&quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你要解码的 JSON 值是整数，你有几个选项。</p>
<p>选项一：直接使用浮点数值:-)</p>
<p>选项二：将浮点数值转换为你需要的整数类型。</p>
<p>选项三：使用 Decoder 类型来解码 JSON，并告诉它使用 Number 接口类型来表示 JSON 数字。</p>
<p>选项四：使用结构体类型将你的数字值映射到你需要的数字类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">		Status <span class="type">uint64</span> <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;result =&gt; %+v&quot;</span>, result)</span><br><span class="line">	<span class="comment">//prints: result =&gt; &#123;Status:200&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选项五：如果你需要defer 值的解码，可以使用一个将你的数字值映射到 json.RawMessage 类型的结构体。</p>
<h4 id="JSON-字符串值不支持十六进制或其他非-UTF-8-转义序列"><a href="#JSON-字符串值不支持十六进制或其他非-UTF-8-转义序列" class="headerlink" title="JSON 字符串值不支持十六进制或其他非 UTF-8 转义序列"></a>JSON 字符串值不支持十六进制或其他非 UTF-8 转义序列</h4><p>Go 期望字符串值是 UTF-8 编码的。这意味着你不能在 JSON 字符串中包含任意的十六进制转义的二进制数据（你还必须转义反斜杠字符）。实际上这是 JSON 的一个陷阱，而 Go 借鉴了这个特性，它在 Go 应用程序中经常出现，因此还是有必要提到的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="type">string</span> <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  raw := []<span class="type">byte</span>(<span class="string">`&#123;&quot;data&quot;:&quot;\xc2&quot;&#125;`</span>)</span><br><span class="line">  <span class="keyword">var</span> decoded config</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := json.Unmarshal(raw, &amp;decoded); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    <span class="comment">//prints: invalid character &#x27;x&#x27; in string escape code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Go 发现十六进制转义序列，Unmarshal&#x2F;Decode 调用将失败。如果你确实需要在字符串中包含反斜杠，请确保用另一个反斜杠进行转义。如果你想使用十六进制编码的二进制数据，可以转义反斜杠，然后在 JSON 字符串中使用解码后的数据进行自己的十六进制转义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	raw := []<span class="type">byte</span>(<span class="string">`&#123;&quot;data&quot;:&quot;\\xc2&quot;&#125;`</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> decoded config</span><br><span class="line"></span><br><span class="line">	json.Unmarshal(raw, &amp;decoded)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v&quot;</span>, decoded) <span class="comment">//prints: main.config&#123;Data:&quot;\\xc2&quot;&#125;</span></span><br><span class="line">	<span class="comment">//todo: do your own hex escape decoding for decoded.Data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比较Structs-Arrays-Slices-and-Maps"><a href="#比较Structs-Arrays-Slices-and-Maps" class="headerlink" title="比较Structs, Arrays, Slices, and Maps"></a>比较Structs, Arrays, Slices, and Maps</h4><p>如果每个结构体字段都可以使用等于运算符进行比较，那么可以使用等于运算符（&#x3D;&#x3D;）比较结构体变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	num     <span class="type">int</span></span><br><span class="line">	fp      <span class="type">float32</span></span><br><span class="line">	<span class="built_in">complex</span> <span class="type">complex64</span></span><br><span class="line">	str     <span class="type">string</span></span><br><span class="line">	char    <span class="type">rune</span></span><br><span class="line">	yes     <span class="type">bool</span></span><br><span class="line">	events  &lt;-<span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">	handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	ref     *<span class="type">byte</span></span><br><span class="line">	raw     [<span class="number">10</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v1 := data&#123;num: <span class="number">1</span>&#125;</span><br><span class="line">	v2 := data&#123;num: <span class="number">1</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;v1 == v2:&quot;</span>, v1 == v2) <span class="comment">//prints: v1 == v2: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果任何结构体字段不可比较，则使用等于运算符会导致编译时错误。注意，仅当数组的数据项可比较时，数组才可比较。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	num    <span class="type">int</span>               <span class="comment">//ok</span></span><br><span class="line">	checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>   <span class="comment">//not comparable</span></span><br><span class="line">	doit   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>       <span class="comment">//not comparable</span></span><br><span class="line">	m      <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="comment">//not comparable</span></span><br><span class="line">	bytes  []<span class="type">byte</span>            <span class="comment">//not comparable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v1 := data&#123;&#125;</span><br><span class="line">	v2 := data&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;v1 == v2:&quot;</span>, v1 == v2) <span class="comment">// invalid operation: cannot compare v1 == v2 (struct containing [10]func() bool cannot be compared)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 提供了许多帮助函数来比较无法使用比较运算符进行比较的变量。</p>
<p>最通用的解决方案是使用 reflect 包中的 DeepEqual() 函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	num    <span class="type">int</span>               <span class="comment">//ok</span></span><br><span class="line">	checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>   <span class="comment">//not comparable</span></span><br><span class="line">	doit   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>       <span class="comment">//not comparable</span></span><br><span class="line">	m      <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="comment">//not comparable</span></span><br><span class="line">	bytes  []<span class="type">byte</span>            <span class="comment">//not comparable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v1 := data&#123;&#125;</span><br><span class="line">	v2 := data&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;v1 == v2:&quot;</span>, reflect.DeepEqual(v1, v2)) <span class="comment">//prints: v1 == v2: true</span></span><br><span class="line"></span><br><span class="line">	m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">	m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;m1 == m2:&quot;</span>, reflect.DeepEqual(m1, m2)) <span class="comment">//prints: m1 == m2: true</span></span><br><span class="line"></span><br><span class="line">	s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	s2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;s1 == s2:&quot;</span>, reflect.DeepEqual(s1, s2)) <span class="comment">//prints: s1 == s2: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了性能慢（这可能或可能不是应用程序的关键问题）之外，DeepEqual() 也有自己的陷阱。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">	b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;b1 == b2:&quot;</span>, reflect.DeepEqual(b1, b2)) <span class="comment">//prints: b1 == b2: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeepEqual() 不认为空切片和“nil”切片是相等的。这种行为与使用 bytes.Equal() 函数得到的行为不同。bytes.Equal() 认为“nil”和空切片是相等的。</p>
<p>DeepEqual() 并不总是完美地比较切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;one&quot;</span></span><br><span class="line">	<span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;one&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;str == in:&quot;</span>, str == in, reflect.DeepEqual(str, in))</span><br><span class="line">	<span class="comment">//prints: str == in: true true</span></span><br><span class="line"></span><br><span class="line">	v1 := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">	v2 := []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;v1 == v2:&quot;</span>, reflect.DeepEqual(v1, v2))</span><br><span class="line">	<span class="comment">//prints: v1 == v2: false (not ok)</span></span><br><span class="line"></span><br><span class="line">	data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">&quot;code&quot;</span>:  <span class="number">200</span>,</span><br><span class="line">		<span class="string">&quot;value&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	encoded, _ := json.Marshal(data)</span><br><span class="line">	<span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	json.Unmarshal(encoded, &amp;decoded)</span><br><span class="line">	fmt.Println(<span class="string">&quot;data == decoded:&quot;</span>, reflect.DeepEqual(data, decoded))</span><br><span class="line">	<span class="comment">//prints: data == decoded: false (not ok)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的字节切片（或字符串）包含文本数据，并且需要以不区分大小写的方式比较值（在使用 &#x3D;&#x3D;、bytes.Equal() 或 bytes.Compare() 之前），你可能会尝试使用“bytes”和“strings”包中的 ToUpper() 或 ToLower()。这对于英文文本可以正常工作，但对于许多其他语言的文本不起作用。应该使用 strings.EqualFold() 和 bytes.EqualFold()。</p>
<p>如果你的字节切片包含机密信息（例如加密哈希、令牌等），需要根据用户提供的数据进行验证，请不要使用 reflect.DeepEqual()、bytes.Equal() 或 bytes.Compare()，因为这些函数将使你的应用程序容易受到时序攻击的威胁。为了避免泄露时序信息，请使用“crypto&#x2F;subtle”包中的函数（例如 subtle.ConstantTimeCompare()）来进行比较。</p>
<h4 id="从-Panic-情况中恢复"><a href="#从-Panic-情况中恢复" class="headerlink" title="从 Panic 情况中恢复"></a>从 Panic 情况中恢复</h4><p>recover() 函数可以用于捕获&#x2F;拦截 panic。只有<strong>在defer函数中调用 recover() 函数</strong>才能做到这一点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;recovered:&quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 recover() 函数仅在<strong>直接</strong>在defer函数中调用时起作用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRecover</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;recovered =&gt;&quot;</span>,<span class="built_in">recover</span>()) <span class="comment">//prints: recovered =&gt; &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        doRecover() <span class="comment">//panic is not recovered</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>在 range 迭代 slice、array、map 时通过更新引用来更新元素</h4><p>在 range 迭代中，得到的值其实是元素的一份值拷贝，<strong>更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v *= <span class="number">10</span>        <span class="comment">// data 中原有元素是不会被修改的</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要修改原有元素的值，应该使用索引直接访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        data[i] = v * <span class="number">10</span>    </span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []*<span class="keyword">struct</span>&#123; num <span class="type">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="built_in">println</span>(v)  <span class="comment">// 0xc00001a0a8 0xc00001a0c0 0xc00001a0c8</span></span><br><span class="line">		v.num *= <span class="number">10</span> <span class="comment">// 直接使用指针更新</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>]) <span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="slice-中隐藏的数据"><a href="#slice-中隐藏的数据" class="headerlink" title="slice 中隐藏的数据"></a>slice 中隐藏的数据</h4><p>从 slice 中重新切出新 slice 时，<strong>新 slice 会引用原 slice 的底层数组</strong>。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>]) <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">	<span class="keyword">return</span> raw[:<span class="number">3</span>]                           <span class="comment">// 重新分配容量为 10000 的 slice</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := get()</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>]) <span class="comment">// 3 10000 0xc420080000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过<strong>拷贝临时 slice 的数据</strong>，而不是重新切片来解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> (res []<span class="type">byte</span>) &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    res = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res, raw[:<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])    <span class="comment">// 3 3 0xc4200160b8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Slice-中数据的误用"><a href="#Slice-中数据的误用" class="headerlink" title="Slice 中数据的误用"></a>Slice 中数据的误用</h4><p>举个简单例子，重写文件路径（存储在 slice 中）</p>
<p>分割路径来指向每个不同级的目录，修改第一个目录名再重组子目录名，创建新路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误使用 slice 的拼接示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">println</span>(sepIndex)</span><br><span class="line"></span><br><span class="line">    dir1 := path[:sepIndex]</span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAA</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">&quot;current path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffixBBBB</span></span><br><span class="line">    </span><br><span class="line">    path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAAsuffix</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// uffixBBBB</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffix/uffixBBBB    // 错误结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拼接的结果不是正确的 <code>AAAAsuffix/BBBBBBBBB</code>，因为 dir1、 dir2 两个 slice 引用的数据都是 <code>path</code> 的底层数组，第 13 行修改 <code>dir1</code> 同时也修改了 <code>path</code>，<strong>也导致了 <code>dir2</code> 的修改</strong></p>
<p>解决方法：</p>
<ul>
<li><strong>重新分配新的 slice</strong> 并拷贝你需要的数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个原始切片</span></span><br><span class="line">	originalSlice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个新的切片，指定长度和容量</span></span><br><span class="line">	newSlice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 copy 函数将需要的数据从原始切片复制到新的切片中</span></span><br><span class="line">	<span class="built_in">copy</span>(newSlice, originalSlice[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在新的切片中添加更多的元素</span></span><br><span class="line">	newSlice = <span class="built_in">append</span>(newSlice, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出新的切片</span></span><br><span class="line">	fmt.Println(newSlice)      <span class="comment">// [2 3 4 6 7 8]</span></span><br><span class="line">	fmt.Println(originalSlice) <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用完整的 slice 表达式：<code>input[low:high:max]</code>，容量便调整为 max - low</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 full slice expression</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">	sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">	dir1 := path[:sepIndex:sepIndex]       <span class="comment">// 此时 cap(dir1) 指定为4， 而不是先前的 16</span></span><br><span class="line">	dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">	dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">	path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))     <span class="comment">// AAAAsuffix</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))     <span class="comment">// BBBBBBBBB</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path)) <span class="comment">// AAAAsuffix/BBBBBBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 6 行中第三个参数是用来控制 dir1 的新容量，再往 dir1 中 <strong>append 超额元素时，将分配新的 buffer 来保存。而不是覆盖原来的 path</strong> 底层数组.</p>
<h4 id="旧-slice"><a href="#旧-slice" class="headerlink" title="旧 slice"></a>旧 slice</h4><p>当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。</p>
<p>某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。<strong>而其他 slice 还指向原来的旧底层数组。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过容量将重新分配数组来拷贝值、重新存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)    <span class="comment">// 3 3 [1 2 3 ]</span></span><br><span class="line"></span><br><span class="line">    s2 := s1[<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)    <span class="comment">// 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时的 s1 与 s2 是指向同一个底层数组的</span></span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [22 23]</span></span><br><span class="line"></span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">4</span>)    <span class="comment">// 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]    // 此时的 s1 不再更新，为旧数据</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型声明与方法"><a href="#类型声明与方法" class="headerlink" title="类型声明与方法"></a>类型声明与方法</h4><p>从一个现有的非 interface 类型创建新类型时，<strong>并不会继承原有的方法：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Mutex 的自定义类型</span></span><br><span class="line"><span class="keyword">type</span> myMutex sync.Mutex <span class="comment">// type Mutex struct</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mtx myMutex</span><br><span class="line">    mtx.Lock()</span><br><span class="line">    mtx.UnLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你需要使用原类型的方法，可将原类型<strong>以匿名字段的形式嵌到你定义的新 struct 中</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型以字段形式直接嵌入</span></span><br><span class="line"><span class="keyword">type</span> myLocker <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> locker myLocker</span><br><span class="line">    locker.Lock()</span><br><span class="line">    locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface 类型声明也保留它的方法集：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myLocker sync.Locker <span class="comment">// type Locker interface</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> locker myLocker</span><br><span class="line">    locker.Lock()</span><br><span class="line">    locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跳出-for-switch-和-for-select-代码块"><a href="#跳出-for-switch-和-for-select-代码块" class="headerlink" title="跳出 for-switch 和 for-select 代码块"></a>跳出 for-switch 和 for-select 代码块</h4><p>没有指定标签的 <strong>break 只会跳出 switch&#x2F;select 语句</strong>，若不能使用 return 语句跳出的话，可为 break 跳出<strong>标签指定的代码块</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// break 配合 label 跳出指定代码块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;breaking out...&quot;</span>)</span><br><span class="line">            <span class="comment">//break    // 死循环，一直打印 breaking out...</span></span><br><span class="line">            <span class="keyword">break</span> loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;out...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for-语句中的迭代变量与闭包函数"><a href="#for-语句中的迭代变量与闭包函数" class="headerlink" title="for 语句中的迭代变量与闭包函数"></a>for 语句中的迭代变量与闭包函数</h4><p>for 语句中的<strong>迭代变量在每次迭代中都会重用</strong>，即 for 中创建的闭包函数接收到的参数始终是同一个变量，在 goroutine 开始执行时都会得到同一个迭代值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的解决方法：无需修改 goroutine 函数，在 for 内部使用局部变量保存迭代值，再传参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		vCopy := v</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(vCopy)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(in)</span><br><span class="line">        &#125;(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="defer-函数的参数值"><a href="#defer-函数的参数值" class="headerlink" title="defer 函数的参数值"></a>defer 函数的参数值</h4><p>对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 defer 函数中参数会提前求值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;result: &quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;()) <span class="comment">// result:  2</span></span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="defer-函数的执行时机"><a href="#defer-函数的执行时机" class="headerlink" title="defer 函数的执行时机"></a>defer 函数的执行时机</h4><p>对 defer 延迟执行的函数，会在<strong>调用它的函数结束时执行</strong>，而不是在调用它的语句块结束时执行，注意区分开。</p>
<p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行参数指定目录名</span></span><br><span class="line"><span class="comment">// 遍历读取目录下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dir := os.Args[<span class="number">1</span>]</span><br><span class="line">    start, err := os.Stat(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir() &#123;</span><br><span class="line">        os.Exit(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="type">string</span></span><br><span class="line">    filepath.Walk(dir, <span class="function"><span class="keyword">func</span><span class="params">(fPath <span class="type">string</span>, fInfo os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fInfo.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets, fPath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        f, err := os.Open(target)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)    <span class="comment">//error:too many open files</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()    <span class="comment">// 在每次 for 语句块结束时，不会关闭文件资源，文件过多会产生错误</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 f 资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法：defer 延迟执行的函数<strong>写入匿名函数</strong>中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目录遍历正常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Open(target)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span>    <span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close()    <span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用 f 资源</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 <code>f.Close()</code> 来关闭。</p>
<h4 id="失败的类型断言"><a href="#失败的类型断言" class="headerlink" title="失败的类型断言"></a>失败的类型断言</h4><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 混用</span></span><br><span class="line">    <span class="keyword">if</span> data, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)    <span class="comment">// [isn&#x27;t a int], data:  0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)    <span class="comment">// [not an int], data:  great</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="阻塞的-gorutinue-与资源泄露"><a href="#阻塞的-gorutinue-与资源泄露" class="headerlink" title="阻塞的 gorutinue 与资源泄露"></a>阻塞的 gorutinue 与资源泄露</h4><p>在 2012 年 Google I&#x2F;O 大会上，Rob Pike 的 <a href="https://link.segmentfault.com/?enc=imam3wl24XqIBVD2DD037g==.v6pttP/N9Lj+J8sgmjutVs1NUt3iINZbP3SXnV8kgzpCE1IGaAysfsnbTvK8Cl9zYC2dJAFEyXO0Qb9h3uJYmA==">Go Concurrency Patterns</a> 演讲讨论 Go 的几种基本并发模式，如 <a href="https://link.segmentfault.com/?enc=szCKlIz3DLsOp2dItu8DZg==.4p3m5FYuMe/KsWWcRty8C9TQHrxtNet/KTcAgSngDfG/uWY+pP8A3uuFah+EBvj/tDaYVf1kHmE8zYyunhqmIognrJnS96TEQgvoSKAQxxQ=">完整代码</a> 中从数据集中获取第一条数据的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas []Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    replicaSearch := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> replicaSearch(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在搜索重复时依旧每次都起一个 goroutine 去处理，每个 goroutine 都把它的搜索结果发送到结果 channel 中，channel 中收到的第一条数据会直接返回。</p>
<p>返回完第一条数据后，其他 goroutine 的搜索结果怎么处理？他们自己的协程如何处理？</p>
<p>在 <code>First()</code> 中的结果 channel 是无缓冲的，这意味着只有第一个 goroutine 能返回，由于没有 receiver，<strong>其他的 goroutine 会在发送上一直阻塞</strong>。如果你大量调用，则可能造成资源泄露。</p>
<p>为避免泄露，你应该确保所有的 goroutine 都能正确退出，有 2 个解决方法：</p>
<ul>
<li>使用带缓冲的 channel，确保能接收全部 goroutine 的返回结果：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="built_in">len</span>(replicas))    </span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 select 语句，配合能保存一个缓冲值的 channel default 语句：<br>default 的缓冲 channel 保证了即使结果 channel 收不到数据，也不会阻塞 goroutine。<code>default</code> 关键字在 <code>select</code> 语句中的作用是在所有通道都不可用时执行，即没有数据可读或者写入的情况。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="number">1</span>)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用特殊的废弃（cancellation） channel 来中断剩余 goroutine 的执行：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;  </span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><h4 id="使用指针作为方法的-receiver"><a href="#使用指针作为方法的-receiver" class="headerlink" title="使用指针作为方法的 receiver"></a>使用指针作为方法的 receiver</h4><p>只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。</p>
<p>但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;name:&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := data&#123;<span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">	d1.<span class="built_in">print</span>() <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// var in printer = data&#123;&quot;two&quot;&#125; //error</span></span><br><span class="line">	<span class="comment">// in.print()</span></span><br><span class="line"></span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;<span class="string">&quot;x&quot;</span>: data&#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">	d2 := m[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">	d2.<span class="built_in">print</span>()</span><br><span class="line">	m[<span class="string">&quot;x&quot;</span>].<span class="built_in">print</span>() <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 会自动将值接收者转换为指针接收者。当你调用 <code>d2.print()</code> 时，Go 会自动将其转换为 <code>(&amp;d2).print()</code>。所以即使 <code>d2</code> 是一个 <code>data</code> 类型而不是 <code>*data</code> 类型，调用 <code>d2.print()</code> 也是有效的。</p>
<p>请注意，这种转换仅在方法接收者是值的情况下发生。在映射项上直接调用指针接收者方法是不允许的，因为 Go 不允许直接对映射项的地址进行操作。这就是为什么 <code>m[&quot;x&quot;].print()</code> 会报错。</p>
<h4 id="更新-map-字段的值"><a href="#更新-map-字段的值" class="headerlink" title="更新 map 字段的值"></a>更新 map 字段的值</h4><p>如果你有一个结构体值的映射，你无法更新单个结构体字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fails</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data &#123;<span class="string">&quot;x&quot;</span>:&#123;<span class="string">&quot;one&quot;</span>&#125;&#125;</span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;two&quot;</span> <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这不起作用是因为映射项不可寻址。</p>
<p>对于新的Go开发人员来说，可能会更加困惑的是，切片元素是可寻址的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s := []data &#123;&#123;<span class="string">&quot;one&quot;</span>&#125;&#125;</span><br><span class="line">    s[<span class="number">0</span>].name = <span class="string">&quot;two&quot;</span> <span class="comment">//ok</span></span><br><span class="line">    fmt.Println(s)    <span class="comment">//prints: [&#123;two&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，一段时间以前，在Go编译器（gccgo）中可以更新映射元素字段，但这种行为很快被修复了 :-) 它也被认为是Go 1.3的一个潜在功能。在当时，这个功能还不够重要，因此它仍在待办列表中。</p>
<p>第一个解决方法是<strong>使用一个临时变量</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;<span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;one&quot;</span>&#125;&#125;</span><br><span class="line">	r := m[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">	r.name = <span class="string">&quot;two&quot;</span></span><br><span class="line">	m[<span class="string">&quot;x&quot;</span>] = r</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>, m) <span class="comment">//prints: map[x:&#123;two&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个解决方法是使用指针的映射。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;<span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;one&quot;</span>&#125;&#125;</span><br><span class="line">	m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;two&quot;</span> <span class="comment">//ok</span></span><br><span class="line">	fmt.Println(m[<span class="string">&quot;x&quot;</span>]) <span class="comment">//prints: &amp;&#123;two&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>By the way, what happens when you run this code?</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]*data &#123;<span class="string">&quot;x&quot;</span>:&#123;<span class="string">&quot;one&quot;</span>&#125;&#125;</span><br><span class="line">    m[<span class="string">&quot;z&quot;</span>].name = <span class="string">&quot;what?&quot;</span> <span class="comment">//???  panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="“nil”-Interfaces-and-“nil”-Interfaces-Values"><a href="#“nil”-Interfaces-and-“nil”-Interfaces-Values" class="headerlink" title="“nil” Interfaces and “nil” Interfaces Values"></a><strong>“nil” Interfaces and “nil” Interfaces Values</strong></h4><p>这是Go语言中第二常见的陷阱，因为尽管接口看起来像指针，但它们实际上不是指针。<strong>只有当接口类型和值字段都为“nil”时，接口变量才为“nil”。</strong></p>
<p>接口类型和值字段是<strong>基于用于创建相应接口变量的变量的类型和值进行填充的</strong>。当您尝试检查接口变量是否等于“nil”时，这可能会导致意外的行为。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data *<span class="type">byte</span></span><br><span class="line">	<span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(data, data == <span class="literal">nil</span>) <span class="comment">//prints: &lt;nil&gt; true</span></span><br><span class="line">	fmt.Println(in, in == <span class="literal">nil</span>)     <span class="comment">//prints: &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">	in = data</span><br><span class="line">	fmt.Println(in, in == <span class="literal">nil</span>) <span class="comment">//prints: &lt;nil&gt; false</span></span><br><span class="line">	<span class="comment">//&#x27;data&#x27; is &#x27;nil&#x27;, but &#x27;in&#x27; is not &#x27;nil&#x27;  in的接口类型不是nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当您有一个返回接口的函数时，要注意这个陷阱。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    doit := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doit(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;good result:&quot;</span>,res) <span class="comment">//prints: good result: &lt;nil&gt;</span></span><br><span class="line">        <span class="comment">//&#x27;res&#x27; is not &#x27;nil&#x27;, but its value is &#x27;nil&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Works:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    doit := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//return an explicit &#x27;nil&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doit(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;good result:&quot;</span>,res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;bad result (res is nil)&quot;</span>) <span class="comment">//here as expected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Stack-and-Heap-Variables"><a href="#Stack-and-Heap-Variables" class="headerlink" title="Stack and Heap Variables"></a><strong>Stack and Heap Variables</strong></h4><p>您并不总是知道<strong>变量是在堆上还是栈上分配的</strong>。在C++中，使用new运算符创建变量总是意味着您有一个堆变量。在Go中，即使使用new()或make()函数，编译器也会决定变量将被分配到哪里。<strong>编译器根据变量的大小和“逃逸分析”的结果选择存储变量的位置</strong>。这也意味着可以返回对局部变量的引用，这在其他语言（如C或C++）是不可以的。</p>
<p>如果您需要知道变量分配在哪里，请将“-m” gc 标志传递给“go build”或“go run”（例如，go run -gcflags -m app.go）。</p>
<h4 id="GOMAXPROCS-Concurrency-and-Parallelism"><a href="#GOMAXPROCS-Concurrency-and-Parallelism" class="headerlink" title="GOMAXPROCS, Concurrency, and Parallelism"></a><strong>GOMAXPROCS, Concurrency, and Parallelism</strong></h4><p>Go 1.4及以下版本仅使用一个执行上下文&#x2F;操作系统线程。这意味着任意给定时间只有一个goroutine可以执行。从1.5开始，Go将执行上下文的数量设置为runtime.NumCPU()返回的逻辑CPU核心数。这个数字可能与您的系统上的逻辑CPU核心总数匹配，也可能不匹配，这取决于您的进程的CPU亲和性设置。您可以通过更改GOMAXPROCS环境变量或调用runtime.GOMAXPROCS()函数来调整这个数字。</p>
<p>有一个普遍的误解，即GOMAXPROCS表示Go将用于运行goroutine的CPU数。runtime.GOMAXPROCS()函数的文档增加了更多的混淆。GOMAXPROCS变量描述（<a href="https://golang.org/pkg/runtime/%EF%BC%89%E6%9B%B4%E5%A5%BD%E5%9C%B0%E8%AE%A8%E8%AE%BA%E4%BA%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E3%80%82">https://golang.org/pkg/runtime/）更好地讨论了操作系统线程。</a></p>
<p>您可以将GOMAXPROCS设置为大于CPU数量的值。从1.10开始，GOMAXPROCS不再有限制。 GOMAXPROCS的最大值曾经是256，后来在1.9中增加到1024。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">//prints: 12 (1 on play.golang.org)</span></span><br><span class="line">	fmt.Println(runtime.NumCPU())       <span class="comment">//prints: 12 (1 on play.golang.org)</span></span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">	fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">//prints: 20</span></span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">	fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">//prints: 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtime.GOMAXPROCS函数用于设置程序中同时运行的最大CPU数。GOMAXPROCS控制Go程序中可同时执行的最大操作系统线程数（即同时运行的goroutine数）。在多核CPU上，这可以显著提高程序的性能。默认情况下，GOMAXPROCS的值等于机器的CPU核心数。您可以通过调用runtime.GOMAXPROCS()函数来更改此值。</p>
<p>需要注意的是，将GOMAXPROCS设置为大于CPU核心数的值并不一定会提高程序的性能，因为这可能会导致过多的上下文切换。过多的上下文切换会降低程序的性能，因为它们会增加开销，减少CPU时间片的使用效率。</p>
<h4 id="读取和写入操作重新排序"><a href="#读取和写入操作重新排序" class="headerlink" title="读取和写入操作重新排序"></a>读取和写入操作重新排序</h4><p>Go可能会重新排序某些操作，但它确保在发生的goroutine中的总体行为不会改变。然而，它不能保证在多个goroutine之间的执行顺序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u1</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u2</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    b = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">    <span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> u1()</span><br><span class="line">    <span class="keyword">go</span> u2()</span><br><span class="line">    <span class="keyword">go</span> p() <span class="comment">// 输出结果不确定</span></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b可能在a之前被更新。，如果您需要在多个goroutine之间保留读取和写入操作的顺序，您需要使用通道或“sync”包中适当的构造。</p>
<h4 id="抢占式调度（Preemptive-Scheduling）"><a href="#抢占式调度（Preemptive-Scheduling）" class="headerlink" title="抢占式调度（Preemptive Scheduling）"></a>抢占式调度（Preemptive Scheduling）</h4><p>有可能存在一个恶意的goroutine阻止其他goroutine运行。如果您有一个不允许调度程序运行的for循环，这种情况可能会发生。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环并不一定要是空的。只要它包含不会触发调度程序执行的代码，就会成为一个问题。</p>
<p>调度程序将在GC、”go”语句、阻塞通道操作、阻塞系统调用和锁操作之后运行。当调用非内联函数时，调度程序也可能会运行。</p>
<p>这段代码中，<code>done</code> 变量在主 Goroutine 和新创建的匿名 Goroutine 之间共享。主 Goroutine 在 <code>for !done</code> 循环中检查 <code>done</code> 变量的值，而新创建的 Goroutine 修改 <code>done</code> 的值。这会导致竞态条件，因为两个 Goroutine 同时访问和修改同一个变量，可能导致不可预知的行为。</p>
<p>在原始代码中，主 Goroutine 会一直执行 <code>for !done</code> 循环，检查 <code>done</code> 变量是否为 <code>true</code>。然而，由于 Go 的内存模型，主 Goroutine 可能无法看到其他 Goroutine 对 <code>done</code> 变量所做的更改。这可能导致死循环，使程序无法终止。通过使用通道（channel）进行同步，如下面的修改后的示例所示，可以解决这个问题。。</p>
<p>为了解决这个问题，可以使用通道（channel）来同步 Goroutine 之间的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">&quot;done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要找出在for循环中调用的函数是否被内联，请将“-m”gc标志传递给“go build”或“go run”（例如，go build -gcflags -m）。</p>
<p>另一个选择是显式调用调度程序。您可以使用“runtime”包中的Gosched()函数来执行此操作。</p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Stupid Gopher Tricks</title>
    <url>/2023/03/24/Stupid-Gopher-Tricks/</url>
    <content><![CDATA[<h1 id="Stupid-Gopher-Tricks"><a href="#Stupid-Gopher-Tricks" class="headerlink" title="Stupid Gopher Tricks"></a>Stupid Gopher Tricks</h1><h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h2><h4 id="Type-literals"><a href="#Type-literals" class="headerlink" title="Type literals"></a>Type literals</h4><p>这里是一个熟悉的类型声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型声明的后半部分是类型字面量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他类型字面量的例子包括 int 和 []string，它们也可以声明为命名类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Bar <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> Qux []<span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>虽然我们通常在变量声明中使用 int 和 []string：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>但是对于结构体，使用相同的方式不太常见（但同样有效）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个未命名的结构体字面量通常被称为<strong>匿名结构体</strong>。</p>
<h4 id="Anonymous-structs-template-data"><a href="#Anonymous-structs-template-data" class="headerlink" title="Anonymous structs: template data"></a>Anonymous structs: template data</h4><p>一个常见的用途是为模板提供数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data := <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title               <span class="type">string</span></span><br><span class="line">    Firstname, Lastname <span class="type">string</span></span><br><span class="line">    Rank                <span class="type">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    <span class="string">&quot;Dr&quot;</span>, <span class="string">&quot;Carl&quot;</span>, <span class="string">&quot;Sagan&quot;</span>, <span class="number">7</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := tmpl.Execute(os.Stdout, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以使用 map[string]interface{}，但那样会牺牲性能和类型安全。</p>
<h4 id="Anonymous-structs-JSON"><a href="#Anonymous-structs-JSON" class="headerlink" title="Anonymous structs: JSON"></a>Anonymous structs: JSON</h4><p>相同的技术可以用于编码 JSON 对象：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b, err := json.Marshal(<span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;&#123;<span class="number">42</span>, <span class="string">&quot;The answer&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, b)</span><br></pre></td></tr></table></figure>

<p>同样也可以进行解码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(<span class="string">`&#123;&quot;ID&quot;: 42, &quot;Name&quot;: &quot;The answer&quot;&#125;`</span>), &amp;data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(data.ID, data.Name)</span><br></pre></td></tr></table></figure>

<p>结构体可以嵌套以描述更复杂的 JSON 对象：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="type">int</span></span><br><span class="line">    Person <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="type">string</span></span><br><span class="line">        Job  <span class="type">string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="string">`&#123;&quot;ID&quot;:42,&quot;Person&quot;:&#123;&quot;Name&quot;:&quot;George Costanza&quot;,&quot;Job&quot;:&quot;Architect&quot;&#125;&#125;`</span></span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(s), &amp;data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(data.ID, data.Person.Name, data.Person.Job)</span><br></pre></td></tr></table></figure>

<h4 id="Repeated-literals-and-struct-names"><a href="#Repeated-literals-and-struct-names" class="headerlink" title="Repeated literals and struct names"></a>Repeated literals and struct names</h4><p>在像切片和映射这样的重复字面量中，Go 允许您省略内部类型名称：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = []Foo&#123;</span><br><span class="line">    &#123;<span class="number">6</span> * <span class="number">9</span>, <span class="string">&quot;Question&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">42</span>, <span class="string">&quot;Answer&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">int</span>]Foo&#123;</span><br><span class="line">    <span class="number">7</span>: &#123;<span class="number">6</span> * <span class="number">9</span>, <span class="string">&quot;Question&quot;</span>&#125;,</span><br><span class="line">    <span class="number">3</span>: &#123;<span class="number">42</span>, <span class="string">&quot;Answer&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Repeated-literals-and-anonymous-structs"><a href="#Repeated-literals-and-anonymous-structs" class="headerlink" title="Repeated literals and anonymous structs"></a>Repeated literals and anonymous structs</h4><p>结合匿名结构体，这种便利可以大大缩短代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = []<span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        i <span class="type">int</span></span><br><span class="line">        s <span class="type">string</span></span><br><span class="line">    &#125;&#123;<span class="number">6</span> * <span class="number">9</span>, <span class="string">&quot;Question&quot;</span>&#125;,</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        i <span class="type">int</span></span><br><span class="line">        s <span class="type">string</span></span><br><span class="line">    &#125;&#123;<span class="number">42</span>, <span class="string">&quot;Answer&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = []<span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    &#123;<span class="number">6</span> * <span class="number">9</span>, <span class="string">&quot;Question&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">42</span>, <span class="string">&quot;Answer&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Anonymous-structs-test-cases"><a href="#Anonymous-structs-test-cases" class="headerlink" title="Anonymous structs: test cases"></a>Anonymous structs: test cases</h4><p>这些特性使得表达测试用例的方式非常优雅：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIndex</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        s   <span class="type">string</span></span><br><span class="line">        sep <span class="type">string</span></span><br><span class="line">        out <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;fo&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;oofofoofooo&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        <span class="comment">// etc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        actual := strings.Index(test.s, test.sep)</span><br><span class="line">        <span class="keyword">if</span> actual != test.out &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Index(%q,%q) = %v; want %v&quot;</span>, test.s, test.sep, actual, test.out)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以更进一步，将复合字面量放在 range 语句本身中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIndex</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> []<span class="keyword">struct</span> &#123;</span><br><span class="line">        s   <span class="type">string</span></span><br><span class="line">        sep <span class="type">string</span></span><br><span class="line">        out <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;fo&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;oofofoofooo&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        <span class="comment">// etc</span></span><br><span class="line">    &#125; &#123;</span><br><span class="line">        actual := strings.Index(test.s, test.sep)</span><br><span class="line">        <span class="keyword">if</span> actual != test.out &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Index(%q,%q) = %v; want %v&quot;</span>, test.s, test.sep, actual, test.out)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样更难阅读。nonono</p>
<h4 id="Embedded-fields"><a href="#Embedded-fields" class="headerlink" title="Embedded fields"></a>Embedded fields</h4><p>一个没有名称的结构体字段是一个嵌入字段。<br>嵌入类型的方法（如果它是一个结构体，则还包括字段）<br><strong>可以像它们是嵌入结构体的一部分一样访问</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;A&#x27;s String method called: %v&quot;</span>, a.s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := B&#123;&#125;</span><br><span class="line">    b.s = <span class="string">&quot;some value&quot;</span> <span class="comment">//here</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Anonymous-structs-embedded-mutex"><a href="#Anonymous-structs-embedded-mutex" class="headerlink" title="Anonymous structs: embedded mutex"></a>Anonymous structs: embedded mutex</h4><p>当然，您可以在匿名结构体中嵌入字段。</p>
<p>通常用互斥变量保护全局变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    viewCount   <span class="type">int64</span></span><br><span class="line">    viewCountMu sync.Mutex</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通过在匿名结构体中嵌入一个互斥量，我们可以将相关的值分组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> viewCount <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    n <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 viewCount 的用户可以像这样访问它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viewCount.Lock()</span><br><span class="line">viewCount.n++</span><br><span class="line">viewCount.Unlock()</span><br></pre></td></tr></table></figure>

<h4 id="Anonymous-structs-implementing-interfaces"><a href="#Anonymous-structs-implementing-interfaces" class="headerlink" title="Anonymous structs: implementing interfaces"></a>Anonymous structs: implementing interfaces</h4><p>您还可以嵌入接口。</p>
<p>这是 Camlistore 中的一个真实例子：</p>
<p>该函数期望返回一个 <code>ReadSeekCloser</code>，但程序员只有一个字符串 <code>s</code>。</p>
<p>匿名结构体（以及它的标准库朋友们）来拯救！</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    io.ReadSeeker</span><br><span class="line">    io.Closer</span><br><span class="line">&#125;&#123;</span><br><span class="line">    io.NewSectionReader(strings.NewReader(s), <span class="number">0</span>, <span class="type">int64</span>(<span class="built_in">len</span>(s))),</span><br><span class="line">    ioutil.NopCloser(<span class="literal">nil</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in package io</span></span><br><span class="line"><span class="keyword">type</span> ReadSeeker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Seeker</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadSeekCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Seeker</span><br><span class="line">	Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，嵌入匿名类型，带来了字段与方法</p>
<h4 id="Anonymous-interfaces"><a href="#Anonymous-interfaces" class="headerlink" title="Anonymous interfaces"></a>Anonymous interfaces</h4><p>接口可以是匿名的，最常见的是interface{}。</p>
<p>但接口不一定是空的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s <span class="keyword">interface</span> &#123;</span><br><span class="line">		String() <span class="type">string</span></span><br><span class="line">	&#125; = bytes.NewBufferString(<span class="string">&quot;I&#x27;m secretly a fmt.Stringer!&quot;</span>)</span><br><span class="line">	fmt.Println(s.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这对于诡秘的类型断言非常有用（来自src&#x2F;os&#x2F;exec&#x2F;exec_test.go）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check that we can access methods of the underlying os.File.</span></span><br><span class="line"><span class="keyword">if</span> _, ok := stdin.(<span class="keyword">interface</span> &#123;</span><br><span class="line">    Fd() <span class="type">uintptr</span></span><br><span class="line">&#125;); !ok &#123;</span><br><span class="line">    t.Error(<span class="string">&quot;can&#x27;t access methods of underlying *os.File&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Method-values"><a href="#Method-values" class="headerlink" title="Method values"></a>Method values</h4><p>“方法值”指的是将方法作为表达式进行求值的结果，其结果是一个函数值。</p>
<p>从 <em>type</em>中评估方法会产生一个<strong>函数</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(*bytes.Buffer, <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">f = (*bytes.Buffer).WriteString</span><br><span class="line">f(&amp;buf, <span class="string">&quot;y u no buf.WriteString?&quot;</span>)</span><br><span class="line">buf.WriteTo(os.Stdout)</span><br></pre></td></tr></table></figure>

<p>: y u no buf.WriteString?</p>
<p><em><em>从</em>value* 中评估方法会创建一个闭包，其中包含了该*value</em> **：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">f = buf.WriteString</span><br><span class="line">f(<span class="string">&quot;Hey... &quot;</span>)</span><br><span class="line">f(<span class="string">&quot;this *is* cute.&quot;</span>)</span><br><span class="line">buf.WriteTo(os.Stdout)</span><br></pre></td></tr></table></figure>

<p>: Hey… this <em>is</em> cute.</p>
<h4 id="Method-values-sync-Once"><a href="#Method-values-sync-Once" class="headerlink" title="Method values: sync.Once"></a>Method values: sync.Once</h4><p>sync.Once 类型用于实现一次性的任务，并保证并发安全。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Once is an object that will perform exactly one action.</span></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123; <span class="comment">/* Has unexported fields. */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>)</span><br></pre></td></tr></table></figure>

<p>以下的 LazyPrimes 类型在第一次使用时计算一组素数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LazyPrimes <span class="keyword">struct</span> &#123;</span><br><span class="line">    once   sync.Once <span class="comment">// 保护素数切片的并发访问。</span></span><br><span class="line">    primes []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *LazyPrimes)</span></span> init() &#123;</span><br><span class="line">    <span class="comment">// 使用素数填充 p.primes。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *LazyPrimes)</span></span> Primes() []<span class="type">int</span> &#123;</span><br><span class="line">    p.once.Do(p.init)</span><br><span class="line">    <span class="keyword">return</span> p.primes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插：Golang-中的闭包"><a href="#插：Golang-中的闭包" class="headerlink" title="插：Golang 中的闭包"></a>插：Golang 中的闭包</h4><p>在 Go 语言中，闭包是指一个函数能够<strong>捕获并使用其外部作用域中的变量</strong>。<strong>闭包由两部分组成：一个是函数本身，另一个是外部变量的引用</strong>。闭包允许函数在定义时捕获环境状态，并在后续调用中继续使用该状态。</p>
<p>下面是一个典型的 Go 闭包示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createCounter 返回一个匿名函数，该匿名函数能访问并修改其外部作用域中的变量 count</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createCounter</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    counter := createCounter() <span class="comment">// counter 是一个闭包，它捕获了 createCounter 函数中的 count 变量</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(counter()) <span class="comment">// 输出: 1</span></span><br><span class="line">    fmt.Println(counter()) <span class="comment">// 输出: 2</span></span><br><span class="line">    fmt.Println(counter()) <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">    anotherCounter := createCounter() <span class="comment">// 创建一个新的闭包，捕获了一个新的 count 变量</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(anotherCounter()) <span class="comment">// 输出: 1</span></span><br><span class="line">    fmt.Println(anotherCounter()) <span class="comment">// 输出: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>createCounter</code> 函数返回一个匿名函数，该匿名函数可以访问和修改其外部作用域中的 <code>count</code> 变量。每次调用 <code>createCounter()</code>，都会生成一个新的闭包，这个闭包捕获了一个新的 <code>count</code> 变量。在 <code>main</code> 函数中，我们创建了两个闭包：<code>counter</code> 和 <code>anotherCounter</code>。尽管它们都是由 <code>createCounter</code> 函数创建的，但它们捕获了不同的 <code>count</code> 变量，因此它们的状态是独立的。</p>
<p>闭包常用于实现诸如状态封装、生成器、延迟计算和异步操作等功能。在上面的示例中，我们使用闭包来实现一个简单的计数器。这种计数器可以在多次调用之间保持自己的状态，而不需要使用全局变量。</p>
<h4 id="Method-values-HTTP-handlers"><a href="#Method-values-HTTP-handlers" class="headerlink" title="Method values: HTTP handlers"></a>Method values: HTTP handlers</h4><p>您可以使用方法值来使用一个类型实现多个 HTTP 处理程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Server state.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> index(w http.ResponseWriter, r *http.Request)  &#123; <span class="comment">/* Implementation. */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> edit(w http.ResponseWriter, r *http.Request)   &#123; <span class="comment">/* Implementation. */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> <span class="built_in">delete</span>(w http.ResponseWriter, r *http.Request) &#123; <span class="comment">/* Implementation. */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Register(mux *http.ServeMux) &#123;</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/&quot;</span>, s.index)</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/edit/&quot;</span>, s.edit)</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/delete/&quot;</span>, s.<span class="built_in">delete</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Method-values-another-example"><a href="#Method-values-another-example" class="headerlink" title="Method values: another example"></a>Method values: another example</h4><p>在 os&#x2F;exec 包中，Cmd 类型实现了设置标准输入、输出和错误的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cmd)</span></span> stdin() (f *os.File, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cmd)</span></span> stdout() (f *os.File, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cmd)</span></span> stderr() (f *os.File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>调用者<strong>以相同的方式处理每个方法</strong>，因此它会迭代方法值的切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="function"><span class="keyword">func</span><span class="params">(*Cmd)</span></span> (*os.File, <span class="type">error</span>)</span><br><span class="line"><span class="keyword">for</span> _, setupFd := <span class="keyword">range</span> []F&#123;(*Cmd).stdin, (*Cmd).stdout, (*Cmd).stderr&#125; &#123;</span><br><span class="line">    fd, err := setupFd(c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.closeDescriptors(c.closeAfterStart)</span><br><span class="line">        c.closeDescriptors(c.closeAfterWait)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    c.childFiles = <span class="built_in">append</span>(c.childFiles, fd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>啥都可以迭代</p>
<h4 id="Comparable-types"><a href="#Comparable-types" class="headerlink" title="Comparable types"></a>Comparable types</h4><p>Go 规范将一组类型定义为“可比较类型”，它们可以使用 &#x3D;&#x3D; 和 !&#x3D; 进行比较。</p>
<p>布尔值、整数、浮点数、复数、字符串、指针、通道、结构体和接口都是可比较的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span> = <span class="number">42</span>, <span class="number">42</span></span><br><span class="line">fmt.Println(a == b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i, j <span class="keyword">interface</span>&#123;&#125; = a, b</span><br><span class="line">fmt.Println(i == j)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s, t <span class="keyword">struct</span>&#123; i <span class="keyword">interface</span>&#123;&#125; &#125;</span><br><span class="line">s.i, t.i = a, b</span><br><span class="line">fmt.Println(s == t)</span><br></pre></td></tr></table></figure>

<p>仅当结构体的字段是可比较的时，它才是可比较的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> q, r <span class="keyword">struct</span>&#123; s []<span class="type">string</span> &#125;</span><br><span class="line">fmt.Println(q == r) <span class="comment">// invalid operation: cannot compare q == r (struct containing []string cannot be compared)</span></span><br></pre></td></tr></table></figure>

<h4 id="Comparable-types-and-map-keys"><a href="#Comparable-types-and-map-keys" class="headerlink" title="Comparable types and map keys"></a>Comparable types and map keys</h4><p>任何可比较的类型都可以用作映射键。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">a[<span class="number">42</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b := <span class="keyword">map</span>[*T]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">b[&amp;T&#123;&#125;] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">c := <span class="keyword">map</span>[T]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">c[T&#123;<span class="number">37</span>, <span class="string">&quot;hello!&quot;</span>&#125;] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">d := <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">d[<span class="number">42</span>] = <span class="literal">true</span></span><br><span class="line">d[&amp;T&#123;&#125;] = <span class="literal">true</span></span><br><span class="line">d[T&#123;<span class="number">123</span>, <span class="string">&quot;four five six&quot;</span>&#125;] = <span class="literal">true</span></span><br><span class="line">d[ioutil.Discard] = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="Structs-as-map-keys"><a href="#Structs-as-map-keys" class="headerlink" title="Structs as map keys"></a>Structs as map keys</h4><p>以下是来自 Go 持续构建基础设施的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> builderRev <span class="keyword">struct</span> &#123;</span><br><span class="line">    builder, rev <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> br = builderRev&#123;<span class="string">&quot;linux-amd64&quot;</span>, <span class="string">&quot;0cd299&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们在一张映射表中跟踪正在执行的构建。pre-Go 1的方法是首先将数据展开为字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">inflight := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">inflight[br.builder + <span class="string">&quot;-&quot;</span> + br.rev] = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>但是，使用结构体键，您可以避免分配并编写更简洁的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">inflight := <span class="keyword">map</span>[builderRev]<span class="type">bool</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">inflight[br] = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>因为builderRev这个struct可比较</p>
<h4 id="Interfaces-as-map-keys"><a href="#Interfaces-as-map-keys" class="headerlink" title="Interfaces as map keys"></a>Interfaces as map keys</h4><p>以下是来自 Docker 的 broadcastwriter 包的接口映射键示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BroadcastWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    writers <span class="keyword">map</span>[io.WriteCloser]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *BroadcastWriter)</span></span> AddWriter(writer io.WriteCloser) &#123;</span><br><span class="line">    w.Lock()</span><br><span class="line">    w.writers[writer] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    w.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *BroadcastWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    w.Lock()</span><br><span class="line">    <span class="keyword">for</span> sw := <span class="keyword">range</span> w.writers &#123;</span><br><span class="line">        <span class="keyword">if</span> n, err := sw.Write(p); err != <span class="literal">nil</span> || n != <span class="built_in">len</span>(p) &#123;</span><br><span class="line">            <span class="built_in">delete</span>(w.writers, sw)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    w.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Structs-and-interfaces-together-as-map-keys"><a href="#Structs-and-interfaces-together-as-map-keys" class="headerlink" title="Structs and interfaces together as map keys"></a>Structs and interfaces together as map keys</h4><p>一个（非常）人为构造的例子：（永远不要这样做！）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> cons <span class="keyword">struct</span> &#123;</span><br><span class="line">    car <span class="type">string</span></span><br><span class="line">    cdr <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cons)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.cdr == <span class="literal">nil</span> || c.cdr == (cons&#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> c.car</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v %v&quot;</span>, c.car, c.cdr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[cons]<span class="type">string</span>&#123;&#125;</span><br><span class="line">    c := cons&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;life?&quot;</span>, <span class="string">&quot;with my&quot;</span>, <span class="string">&quot;I doing&quot;</span>, <span class="string">&quot;What am&quot;</span>&#125; &#123;</span><br><span class="line">        c = cons&#123;s, c&#125; <span class="comment">// 嵌套，其实没啥意义</span></span><br><span class="line">    &#125;</span><br><span class="line">    m[c] = <span class="string">&quot;No idea.&quot;</span></span><br><span class="line">    fmt.Println(c, m[c])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是说cons可以作为<em>key</em></p>
<h2 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h2><h4 id="sync-x2F-atomic"><a href="#sync-x2F-atomic" class="headerlink" title="sync&#x2F;atomic"></a>sync&#x2F;atomic</h4><p>对于一个简单的计数器，您可以使用 sync&#x2F;atomic 包的函数进行原子更新，而无需使用锁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt64</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> (<span class="built_in">new</span> <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="type">int64</span>, old, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt64</span><span class="params">(addr *<span class="type">int64</span>)</span></span> (val <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="type">int64</span>, val <span class="type">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt64</span><span class="params">(addr *<span class="type">int64</span>, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (old <span class="type">int64</span>)</span><br></pre></td></tr></table></figure>

<p>首先，定义全局变量（适当地进行文档化！）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// viewCount must be updated atomically.</span></span><br><span class="line"><span class="keyword">var</span> viewCount <span class="type">int64</span></span><br></pre></td></tr></table></figure>

<p>然后使用 <code>AddInt64</code> 对其进行递增：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">count := atomic.AddInt64(&amp;viewCount, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这些函数适用于 <code>Int32</code>、<code>Uint32</code>、<code>Int64</code>、<code>Uint64</code>、<code>Pointer</code> 和 <code>Uintptr</code>。</p>
<h4 id="sync-x2F-atomic-Value"><a href="#sync-x2F-atomic-Value" class="headerlink" title="sync&#x2F;atomic.Value"></a>sync&#x2F;atomic.Value</h4><p>另一个共享状态的选项是 atomic.Value。</p>
<p>例如，在多个 <code>goroutine</code> 之间共享配置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Timeout time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config atomic.Value</span><br></pre></td></tr></table></figure>

<p>要设置或更新，使用 Store 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">config.Store(&amp;Config&#123;Timeout: <span class="number">2</span>*time.Second&#125;)</span><br></pre></td></tr></table></figure>

<p>要读取，每个 goroutine 调用 Load 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cfg := config.Load().(*Config)</span><br></pre></td></tr></table></figure>

<p>注意，在同一个 Value 中存储不同类型的值会导致 panic。</p>
<h4 id="sync-x2F-atomic-Value-how-it-works"><a href="#sync-x2F-atomic-Value-how-it-works" class="headerlink" title="sync&#x2F;atomic.Value: how it works"></a>sync&#x2F;atomic.Value: how it works</h4><p><code>atomic.Value</code> 原语的大小与单个interface value相同：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> atomic</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个interface value在运行时由两个指针表示：一个指向type，一个指向value。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ifaceWords is interface&#123;&#125; internal representation.</span></span><br><span class="line"><span class="keyword">type</span> ifaceWords <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ  unsafe.Pointer</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了原子地加载和存储接口值，它使用 <code>atomic.LoadPointer</code> 和 <code>atomic.StorePointer</code> 操作interface value的各个部分。</p>
<p>Store 方法首先验证输入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Store(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of nil value into Value&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后使用 unsafe 将当前和新的 interface{} 值转换为 <code>ifaceWords</code>(<code>ifaceWords</code> 结构用于表示空接口类型 <code>interface&#123;&#125;</code> 的内部表示)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    vp := (*ifaceWords)(unsafe.Pointer(v))</span><br><span class="line">    xp := (*ifaceWords)(unsafe.Pointer(&amp;x))</span><br></pre></td></tr></table></figure>

<p>（<code>unsafe.Pointer</code> 是一种特殊的指针类型，它可以用于实现低级别的内存操作和不安全的类型转换。<code>unsafe.Pointer</code> 提供了一种逃避 Go 语言类型系统的方法，允许你在不同类型的指针之间进行转换，访问底层内存布局，以及执行其他类型安全无法保证的操作。这样我们就可以访问这些 interface 值的内部。）</p>
<p>在加载type field时进行自旋：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        typ := LoadPointer(&amp;vp.typ)</span><br></pre></td></tr></table></figure>

<p>如果它是 nil，则这是第一次存储该值。在类型字段中放置一个标记值（max uintptr）以在我们使用它时“锁定”它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(^<span class="type">uintptr</span>(<span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">// Someone beat us to it. Wait.</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>存储数据字段，然后是类型字段，完成！</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">            StorePointer(&amp;vp.data, xp.data)</span><br><span class="line">            StorePointer(&amp;vp.typ, xp.typ)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果这不是第一次存储，请检查是否已经有存储正在进行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">uintptr</span>(typ) == ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>检查类型是否发生了变化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> typ != xp.typ &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果类型字段是我们期望的，那么继续原子地存储该值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">        StorePointer(&amp;vp.data, xp.data)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Load 方法首先加载接口的类型字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Load() (x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    vp := (*ifaceWords)(unsafe.Pointer(v))</span><br><span class="line">    typ := LoadPointer(&amp;vp.typ)</span><br></pre></td></tr></table></figure>

<p>然后，检查是否已经发生或正在发生存储：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> typ == <span class="literal">nil</span> || <span class="type">uintptr</span>(typ) == ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>否则，加载数据字段并将类型和数据作为新接口值返回：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    data := LoadPointer(&amp;vp.data)</span><br><span class="line">    xp := (*ifaceWords)(unsafe.Pointer(&amp;x))</span><br><span class="line">    xp.typ = typ</span><br><span class="line">    xp.data = data</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="A-note-on-sync-x2F-atomic"><a href="#A-note-on-sync-x2F-atomic" class="headerlink" title="A note on sync&#x2F;atomic"></a>A note on sync&#x2F;atomic</h4><p>通常您不需要使用此包中的东西。</p>
<p><strong>首先尝试使用channels 或 sync 包</strong>。</p>
<p>您几乎肯定不应该编写像 atomic.Value 实现这样的代码。<br>（而且我没有展示全部代码；真正的代码还与运行时有关。）</p>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><h4 id="Subprocess-tests"><a href="#Subprocess-tests" class="headerlink" title="Subprocess tests"></a>Subprocess tests</h4><p>有时您需要测试<strong>进程的行为</strong>，而不仅仅是函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crasher</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Going down in flames!&quot;</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了测试这段代码，我们将测试二进制文件本身作为子进程调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCrasher</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> os.Getenv(<span class="string">&quot;BE_CRASHER&quot;</span>) == <span class="string">&quot;1&quot;</span> &#123;</span><br><span class="line">        Crasher()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    cmd := exec.Command(os.Args[<span class="number">0</span>], <span class="string">&quot;-test.run=TestCrasher&quot;</span>)</span><br><span class="line">    cmd.Env = <span class="built_in">append</span>(os.Environ(), <span class="string">&quot;BE_CRASHER=1&quot;</span>)</span><br><span class="line">    err := cmd.Run()</span><br><span class="line">    <span class="keyword">if</span> e, ok := err.(*exec.ExitError); ok &amp;&amp; !e.Success() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.Fatalf(<span class="string">&quot;process ran with err %q, want exit status 1&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="testing"><a href="#testing" class="headerlink" title="testing"></a>testing</h4><p><code>go test</code> 命令会根据以下步骤创建和执行测试二进制文件：</p>
<ol>
<li>首先，<code>go test</code> 工具会在包的目录中查找以 <code>_test.go</code> 结尾的测试文件。</li>
<li>然后，<code>go test</code> 工具会<strong>构建一个包含源代码、测试文件和 <code>testing</code> 包的临时二进制文件</strong>。</li>
<li>创建测试二进制文件后，<code>go test</code> 工具会运行该文件，执行你的测试用例。</li>
<li>测试完成后，<code>go test</code> 工具会收集测试结果，并将测试二进制文件从磁盘中删除。</li>
</ol>
<p>在之前提到的 <code>TestCrasher</code> 示例中，我们使用 <code>os.Args[0]</code> 引用了<strong>当前测试二进制文件</strong>。<code>os.Args[0]</code> 是一个字符串，表示程序启动时的第一个命令行参数，通常是程序的路径。这里，我们使用 <code>os.Args[0]</code> 创建一个新的 <code>exec.Command</code>，以便在<strong>一个单独的进程</strong>中运行测试函数。这种方法允许我们测试包含 <code>os.Exit</code> 调用的函数，而不影响测试框架的正常运行。</p>
<h4 id="Subprocess-benchmarks"><a href="#Subprocess-benchmarks" class="headerlink" title="Subprocess benchmarks"></a>Subprocess benchmarks</h4><p>Go的CPU和内存分析器会为<strong>整个进程</strong>报告数据。<br>要仅分析并发操作的一侧，可以使用<strong>子进程</strong>。</p>
<p>net&#x2F;http包中的此基准测试会生成一个子进程，以向在主进程中运行的服务器发出请求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkServer</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    b.ReportAllocs()</span><br><span class="line">    <span class="comment">// Child process mode;</span></span><br><span class="line">    <span class="keyword">if</span> url := os.Getenv(<span class="string">&quot;TEST_BENCH_SERVER_URL&quot;</span>); url != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        n, err := strconv.Atoi(os.Getenv(<span class="string">&quot;TEST_BENCH_CLIENT_N&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            res, err := Get(url)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        os.Exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">	res := []<span class="type">byte</span>(<span class="string">&quot;Hello world.\n&quot;</span>)</span><br><span class="line">    ts := httptest.NewServer(HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(rw ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">        rw.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html; charset=utf-8&quot;</span>)</span><br><span class="line">        rw.Write(res)</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="keyword">defer</span> ts.Close()</span><br><span class="line"></span><br><span class="line">    cmd := exec.Command(os.Args[<span class="number">0</span>], <span class="string">&quot;-test.run=XXXX&quot;</span>, <span class="string">&quot;-test.bench=BenchmarkServer$&quot;</span>)</span><br><span class="line">    cmd.Env = <span class="built_in">append</span>([]<span class="type">string</span>&#123;</span><br><span class="line">        fmt.Sprintf(<span class="string">&quot;TEST_BENCH_CLIENT_N=%d&quot;</span>, b.N),</span><br><span class="line">        fmt.Sprintf(<span class="string">&quot;TEST_BENCH_SERVER_URL=%s&quot;</span>, ts.URL),</span><br><span class="line">    &#125;, os.Environ()...)</span><br><span class="line">    <span class="keyword">if</span> out, err := cmd.CombinedOutput(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;Test failure: %v, with output: %s&quot;</span>, err, out)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To run:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -run=XX -bench=BenchmarkServer -benchtime=<span class="number">15</span>s -cpuprofile=http.prof</span><br><span class="line">$ <span class="keyword">go</span> tool pprof http.test http.prof</span><br></pre></td></tr></table></figure>

<h2 id="go-list"><a href="#go-list" class="headerlink" title="go list"></a>go list</h2><h4 id="go-list-1"><a href="#go-list-1" class="headerlink" title="go list"></a>go list</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">help</span> list</span></span><br><span class="line">usage: go list [-e] [-f format] [-json] [build flags] [packages]</span><br><span class="line"></span><br><span class="line">List lists the packages named by the import paths, one per line.</span><br></pre></td></tr></table></figure>

<p>显示路径下的包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go list golang.org/x/oauth2/...</span></span><br><span class="line">golang.org/x/oauth2</span><br><span class="line">...</span><br><span class="line">golang.org/x/oauth2/vk</span><br></pre></td></tr></table></figure>

<p>显示标准库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go list std</span></span><br><span class="line">archive/tar</span><br><span class="line">...</span><br><span class="line">unsafe</span><br></pre></td></tr></table></figure>

<p>显示所有包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go list all</span></span><br></pre></td></tr></table></figure>

<h4 id="go-list-json"><a href="#go-list-json" class="headerlink" title="go list -json"></a>go list -json</h4><p>使用-json标志可以告诉您关于包的所有go工具知道的信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ go list -json bytes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Dir&quot;</span>: <span class="string">&quot;/Users/adg/go/src/bytes&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ImportPath&quot;</span>: <span class="string">&quot;bytes&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;bytes&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Doc&quot;</span>: <span class="string">&quot;Package bytes implements functions for the manipulation of byte slices.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Target&quot;</span>: <span class="string">&quot;/Users/adg/go/pkg/darwin_amd64/bytes.a&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Goroot&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Standard&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Stale&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Root&quot;</span>: <span class="string">&quot;/Users/adg/go&quot;</span>,</span><br><span class="line">    <span class="string">&quot;GoFiles&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;buffer.go&quot;</span>,</span><br><span class="line">        <span class="string">&quot;bytes.go&quot;</span>,</span><br><span class="line">        <span class="string">&quot;bytes_decl.go&quot;</span>,</span><br><span class="line">        <span class="string">&quot;reader.go&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易编写可以使用此数据的程序。</p>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>Learning</tag>
      </tags>
  </entry>
</search>
